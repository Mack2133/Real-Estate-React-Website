import {
  groupBySortedKeys,
  makeArray,
  qsa,
  toItemArray
} from "./chunk-UHMEWT6U.js";
import {
  accessor,
  disabled
} from "./chunk-3T2BHOZF.js";
import {
  require_classnames,
  useEventCallback,
  useInstanceId,
  useMessagesWithDefaults,
  useMounted
} from "./chunk-JMLJIJD3.js";
import {
  require_prop_types
} from "./chunk-4LVSZ64H.js";
import {
  require_react
} from "./chunk-YSDLPTTY.js";
import {
  __toESM
} from "./chunk-ZS7NZCD4.js";

// node_modules/react-widgets/esm/FocusListContext.js
var import_react = __toESM(require_react());
var FocusListContext = import_react.default.createContext(null);
var defaultOpts = {
  behavior: "stop"
};
function useListOption(dataItem2) {
  const ctx = (0, import_react.useContext)(FocusListContext);
  const prevElement = (0, import_react.useRef)(null);
  const ref = (0, import_react.useRef)(null);
  (0, import_react.useLayoutEffect)(() => () => {
    ctx == null ? void 0 : ctx.map.delete(ref.current);
  }, []);
  (0, import_react.useLayoutEffect)(() => {
    if (prevElement.current !== ref.current) {
      ctx == null ? void 0 : ctx.map.delete(prevElement.current);
    }
    prevElement.current = ref.current;
    if (ref.current && (ctx == null ? void 0 : ctx.map.get(ref.current)) !== dataItem2) {
      ctx == null ? void 0 : ctx.map.set(ref.current, dataItem2);
    }
  });
  const focused = dataItem2 === (ctx == null ? void 0 : ctx.focusedItem);
  return [ref, focused, focused ? ctx == null ? void 0 : ctx.activeId : void 0];
}
var useFocusList = ({
  scope: listRef,
  anchorItem,
  focusFirstItem: _focusFirstItem = false,
  scopeSelector: _scopeSelector = "",
  activeId
}) => {
  const map = (0, import_react.useMemo)(() => /* @__PURE__ */ new WeakMap(), []);
  const [focusedItem, setFocusedItem] = (0, import_react.useState)();
  const itemSelector = `${_scopeSelector} [data-rw-focusable]`.trim();
  const get = () => {
    const items = qsa(listRef.current, itemSelector);
    return [items, items.find((e) => e.dataset.rwFocused === "")];
  };
  const list = (0, import_react.useMemo)(() => {
    return {
      size() {
        const [items] = get();
        return items.length;
      },
      get,
      toDataItem: (el) => map.get(el),
      first() {
        const [[first]] = get();
        return first;
      },
      focus(el) {
        if (!el || map.has(el))
          setFocusedItem(el ? map.get(el) : void 0);
      },
      last() {
        const [items] = get();
        return items[items.length - 1];
      },
      next({
        behavior
      } = defaultOpts) {
        const [items, focusedItem2] = get();
        let nextIdx = items.indexOf(focusedItem2) + 1;
        if (nextIdx >= items.length) {
          if (behavior === "loop")
            return items[0];
          if (behavior === "clear")
            return void 0;
          return focusedItem2;
        }
        return items[nextIdx];
      },
      prev({
        behavior
      } = defaultOpts) {
        const [items, focusedItem2] = get();
        let nextIdx = Math.max(0, items.indexOf(focusedItem2)) - 1;
        if (nextIdx < 0) {
          if (behavior === "loop")
            return items[items.length - 1];
          if (behavior === "clear")
            return void 0;
          return focusedItem2;
        }
        return items[nextIdx];
      }
    };
  }, []);
  (0, import_react.useLayoutEffect)(() => {
    if (!anchorItem) {
      list.focus(null);
      return;
    }
    const element = get()[0].find((el) => list.toDataItem(el) === anchorItem);
    list.focus(element);
  }, [anchorItem]);
  (0, import_react.useLayoutEffect)(() => {
    if (!listRef.current)
      return;
    const [, focusedElement] = get();
    const hasItem = focusedElement != null;
    if (!hasItem && _focusFirstItem || hasItem && !listRef.current.contains(focusedElement)) {
      if (_focusFirstItem)
        list.focus(list.first());
      else
        list.focus(null);
    }
  });
  const context = (0, import_react.useMemo)(() => ({
    map,
    focusedItem,
    activeId
  }), [focusedItem, activeId]);
  list.context = context;
  list.getFocused = (0, import_react.useCallback)(() => focusedItem, [focusedItem]);
  list.hasFocused = () => focusedItem !== void 0;
  return list;
};

// node_modules/react-widgets/esm/List.js
var import_classnames3 = __toESM(require_classnames());
var import_prop_types3 = __toESM(require_prop_types());
var import_react12 = __toESM(require_react());

// node_modules/react-widgets/esm/ListOption.js
var import_classnames = __toESM(require_classnames());
var import_prop_types = __toESM(require_prop_types());
var import_react2 = __toESM(require_react());
var _excluded = ["className", "children", "dataItem", "selected", "disabled", "onSelect", "searchTerm"];
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var propTypes = {
  activeId: import_prop_types.default.string,
  dataItem: import_prop_types.default.any,
  selected: import_prop_types.default.bool.isRequired,
  onSelect: import_prop_types.default.func.isRequired,
  component: import_prop_types.default.any
};
function ListOption(_ref) {
  let {
    className,
    children,
    dataItem: dataItem2,
    selected,
    disabled: disabled2,
    onSelect
  } = _ref, props = _objectWithoutPropertiesLoose(_ref, _excluded);
  const [ref, focused, id] = useListOption(dataItem2);
  const handleSelect = (event) => {
    if (onSelect && !disabled2)
      onSelect(dataItem2, event);
  };
  let classes = {
    "rw-state-focus": focused,
    "rw-state-selected": selected,
    "rw-state-disabled": disabled2
  };
  return import_react2.default.createElement("div", _extends({
    id,
    ref,
    role: "option",
    "data-rw-option": "",
    "data-rw-focused": focused ? "" : void 0,
    "data-rw-focusable": !disabled2 ? "" : void 0,
    tabIndex: -1,
    "aria-selected": !!selected,
    className: (0, import_classnames.default)("rw-list-option", className, classes),
    onClick: handleSelect
  }, props), children);
}
ListOption.propTypes = propTypes;
var ListOption_default = ListOption;

// node_modules/react-widgets/esm/ListOptionGroup.js
var import_classnames2 = __toESM(require_classnames());
var import_prop_types2 = __toESM(require_prop_types());
var import_react3 = __toESM(require_react());
var propTypes2 = {
  className: import_prop_types2.default.string,
  component: import_prop_types2.default.string
};
function ListOptionGroup({
  children,
  className,
  component = "div"
}) {
  let Tag = component;
  return import_react3.default.createElement(Tag, {
    tabIndex: "-1",
    role: "separator",
    className: (0, import_classnames2.default)(className, "rw-list-optgroup")
  }, children);
}
ListOptionGroup.propTypes = propTypes2;
var ListOptionGroup_default = ListOptionGroup;

// node_modules/@restart/hooks/esm/useCustomEffect.js
var import_react4 = __toESM(require_react());
function useCustomEffect(effect, dependencies, isEqualOrOptions) {
  const isMounted = useMounted();
  const {
    isEqual: isEqual2,
    effectHook = import_react4.useEffect
  } = typeof isEqualOrOptions === "function" ? {
    isEqual: isEqualOrOptions
  } : isEqualOrOptions;
  const dependenciesRef = (0, import_react4.useRef)();
  dependenciesRef.current = dependencies;
  const cleanupRef = (0, import_react4.useRef)(null);
  effectHook(() => {
    if (cleanupRef.current === null) {
      const cleanup = effect();
      cleanupRef.current = () => {
        if (isMounted() && isEqual2(dependenciesRef.current, dependencies)) {
          return;
        }
        cleanupRef.current = null;
        if (cleanup)
          cleanup();
      };
    }
    return cleanupRef.current;
  });
  (0, import_react4.useDebugValue)(effect);
}
var useCustomEffect_default = useCustomEffect;

// node_modules/dequal/dist/index.mjs
var has = Object.prototype.hasOwnProperty;
function find(iter, tar, key) {
  for (key of iter.keys()) {
    if (dequal(key, tar))
      return key;
  }
}
function dequal(foo, bar) {
  var ctor, len, tmp;
  if (foo === bar)
    return true;
  if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
    if (ctor === Date)
      return foo.getTime() === bar.getTime();
    if (ctor === RegExp)
      return foo.toString() === bar.toString();
    if (ctor === Array) {
      if ((len = foo.length) === bar.length) {
        while (len-- && dequal(foo[len], bar[len]))
          ;
      }
      return len === -1;
    }
    if (ctor === Set) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len;
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp)
            return false;
        }
        if (!bar.has(tmp))
          return false;
      }
      return true;
    }
    if (ctor === Map) {
      if (foo.size !== bar.size) {
        return false;
      }
      for (len of foo) {
        tmp = len[0];
        if (tmp && typeof tmp === "object") {
          tmp = find(bar, tmp);
          if (!tmp)
            return false;
        }
        if (!dequal(len[1], bar.get(tmp))) {
          return false;
        }
      }
      return true;
    }
    if (ctor === ArrayBuffer) {
      foo = new Uint8Array(foo);
      bar = new Uint8Array(bar);
    } else if (ctor === DataView) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo.getInt8(len) === bar.getInt8(len))
          ;
      }
      return len === -1;
    }
    if (ArrayBuffer.isView(foo)) {
      if ((len = foo.byteLength) === bar.byteLength) {
        while (len-- && foo[len] === bar[len])
          ;
      }
      return len === -1;
    }
    if (!ctor || typeof foo === "object") {
      len = 0;
      for (ctor in foo) {
        if (has.call(foo, ctor) && ++len && !has.call(bar, ctor))
          return false;
        if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor]))
          return false;
      }
      return Object.keys(bar).length === len;
    }
  }
  return foo !== foo && bar !== bar;
}

// node_modules/@restart/hooks/esm/useUpdateImmediateEffect.js
var import_react8 = __toESM(require_react());

// node_modules/@restart/hooks/esm/useStableMemo.js
var import_react5 = __toESM(require_react());
function isEqual(a, b) {
  if (a.length !== b.length)
    return false;
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
function useStableMemo(factory, deps) {
  let isValid = true;
  const valueRef = (0, import_react5.useRef)();
  if (!valueRef.current) {
    valueRef.current = {
      deps,
      result: factory()
    };
  } else {
    isValid = !!(deps && valueRef.current.deps && isEqual(deps, valueRef.current.deps));
  }
  const cache = isValid ? valueRef.current : {
    deps,
    result: factory()
  };
  valueRef.current = cache;
  return cache.result;
}

// node_modules/@restart/hooks/esm/useUpdatedRef.js
var import_react6 = __toESM(require_react());
function useUpdatedRef(value) {
  const valueRef = (0, import_react6.useRef)(value);
  valueRef.current = value;
  return valueRef;
}

// node_modules/@restart/hooks/esm/useWillUnmount.js
var import_react7 = __toESM(require_react());
function useWillUnmount(fn) {
  const onUnmount = useUpdatedRef(fn);
  (0, import_react7.useEffect)(() => () => onUnmount.current(), []);
}

// node_modules/@restart/hooks/esm/useUpdateImmediateEffect.js
function useUpdateImmediateEffect(effect, deps) {
  const firstRef = (0, import_react8.useRef)(true);
  const tearDown = (0, import_react8.useRef)();
  useWillUnmount(() => {
    if (tearDown.current)
      tearDown.current();
  });
  useStableMemo(() => {
    if (firstRef.current) {
      firstRef.current = false;
      return;
    }
    if (tearDown.current)
      tearDown.current();
    tearDown.current = effect();
  }, deps);
}
var useUpdateImmediateEffect_default = useUpdateImmediateEffect;

// node_modules/@restart/hooks/esm/useImmediateUpdateEffect.js
var useImmediateUpdateEffect_default = useUpdateImmediateEffect_default;

// node_modules/@restart/hooks/esm/useMutationObserver.js
var import_react9 = __toESM(require_react());
function isDepsEqual([nextElement, nextConfig], [prevElement, prevConfig]) {
  return nextElement === prevElement && dequal(nextConfig, prevConfig);
}
function useMutationObserver(element, config, callback) {
  const [records, setRecords] = (0, import_react9.useState)(null);
  const handler = useEventCallback(callback || setRecords);
  useCustomEffect_default(() => {
    if (!element)
      return;
    const observer = new MutationObserver(handler);
    observer.observe(element, config);
    return () => {
      observer.disconnect();
    };
  }, [element, config], {
    isEqual: isDepsEqual,
    // Intentionally done in render, otherwise observer will miss any
    // changes made to the DOM during this update
    effectHook: useImmediateUpdateEffect_default
  });
  return callback ? void 0 : records || [];
}
var useMutationObserver_default = useMutationObserver;

// node_modules/@restart/hooks/esm/useCallbackRef.js
var import_react10 = __toESM(require_react());
function useCallbackRef() {
  return (0, import_react10.useState)(null);
}

// node_modules/@restart/hooks/esm/useMergedRefs.js
var import_react11 = __toESM(require_react());
var toFnRef = (ref) => !ref || typeof ref === "function" ? ref : (value) => {
  ref.current = value;
};
function mergeRefs(refA, refB) {
  const a = toFnRef(refA);
  const b = toFnRef(refB);
  return (value) => {
    if (a)
      a(value);
    if (b)
      b(value);
  };
}
function useMergedRefs(refA, refB) {
  return (0, import_react11.useMemo)(() => mergeRefs(refA, refB), [refA, refB]);
}
var useMergedRefs_default = useMergedRefs;

// node_modules/react-widgets/esm/List.js
var _excluded2 = ["multiple", "data", "value", "onChange", "accessors", "className", "messages", "disabled", "renderItem", "renderGroup", "searchTerm", "groupBy", "elementRef", "optionComponent", "renderList"];
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var whitelist = ["style", "className", "role", "id", "autocomplete", "size", "tabIndex", "maxLength", "name"];
var whitelistRegex = [/^aria-/, /^data-/, /^on[A-Z]\w+/];
function pickElementProps(props) {
  const result = {};
  Object.keys(props).forEach((key) => {
    if (whitelist.indexOf(key) !== -1 || whitelistRegex.some((r) => !!key.match(r)))
      result[key] = props[key];
  });
  return result;
}
var propTypes3 = {
  data: import_prop_types3.default.array,
  dataKey: accessor,
  textField: accessor,
  onSelect: import_prop_types3.default.func,
  onMove: import_prop_types3.default.func,
  onHoverOption: import_prop_types3.default.func,
  optionComponent: import_prop_types3.default.elementType,
  renderItem: import_prop_types3.default.func,
  renderGroup: import_prop_types3.default.func,
  focusedItem: import_prop_types3.default.any,
  selectedItem: import_prop_types3.default.any,
  searchTerm: import_prop_types3.default.string,
  disabled: disabled.acceptsArray,
  messages: import_prop_types3.default.shape({
    emptyList: import_prop_types3.default.func.isRequired
  })
};
var useScrollFocusedIntoView = (element, observeChanges = false) => {
  const scrollIntoView = (0, import_react12.useCallback)(() => {
    if (!element)
      return;
    let selectedItem = element.querySelector("[data-rw-focused]");
    if (selectedItem && selectedItem.scrollIntoView) {
      selectedItem.scrollIntoView({
        block: "nearest",
        inline: "nearest"
      });
    }
  }, [element]);
  useMutationObserver_default(observeChanges ? element : null, {
    subtree: true,
    attributes: true,
    attributeFilter: ["data-rw-focused"]
  }, scrollIntoView);
  return scrollIntoView;
};
function useHandleSelect(multiple, dataItems, onChange) {
  return (dataItem2, event) => {
    if (multiple === false) {
      onChange(dataItem2, {
        dataItem: dataItem2,
        lastValue: dataItems[0],
        originalEvent: event
      });
      return;
    }
    const checked = dataItems.includes(dataItem2);
    onChange(checked ? dataItems.filter((d) => d !== dataItem2) : [...dataItems, dataItem2], {
      dataItem: dataItem2,
      lastValue: dataItems,
      action: checked ? "remove" : "insert",
      originalEvent: event
    });
  };
}
var List = import_react12.default.forwardRef(function List2(_ref, outerRef) {
  var _elementProps$role;
  let {
    multiple = false,
    data = [],
    value,
    onChange,
    accessors,
    className,
    messages,
    disabled: disabled2,
    renderItem,
    renderGroup,
    searchTerm,
    groupBy,
    elementRef,
    optionComponent: Option = ListOption_default,
    renderList
  } = _ref, props = _objectWithoutPropertiesLoose2(_ref, _excluded2);
  const id = useInstanceId();
  const dataItems = makeArray(value, multiple);
  const groupedData = (0, import_react12.useMemo)(() => groupBy ? groupBySortedKeys(groupBy, data) : void 0, [data, groupBy]);
  const [element, ref] = useCallbackRef();
  const disabledItems = toItemArray(disabled2);
  const {
    emptyList
  } = useMessagesWithDefaults(messages);
  const divRef = useMergedRefs_default(ref, elementRef);
  const handleSelect = useHandleSelect(multiple, dataItems, onChange);
  const scrollIntoView = useScrollFocusedIntoView(element, true);
  let elementProps = pickElementProps(props);
  (0, import_react12.useImperativeHandle)(outerRef, () => ({
    scrollIntoView
  }), [scrollIntoView]);
  function renderOption(item, idx) {
    const textValue = accessors.text(item);
    const itemIsDisabled = disabledItems.includes(item);
    const itemIsSelected = dataItems.includes(item);
    return import_react12.default.createElement(Option, {
      dataItem: item,
      key: `item_${idx}`,
      searchTerm,
      onSelect: handleSelect,
      disabled: itemIsDisabled,
      selected: itemIsSelected
    }, renderItem ? renderItem({
      item,
      searchTerm,
      index: idx,
      text: textValue,
      // TODO: probably remove
      value: accessors.value(item),
      disabled: itemIsDisabled
    }) : textValue);
  }
  const items = groupedData ? groupedData.map(([group, items2], idx) => import_react12.default.createElement("div", {
    role: "group",
    key: `group_${idx}`
  }, import_react12.default.createElement(ListOptionGroup_default, null, renderGroup ? renderGroup({
    group
  }) : group), items2.map(renderOption))) : data.map(renderOption);
  const rootProps = Object.assign({
    id,
    tabIndex: 0,
    ref: divRef
  }, elementProps, {
    "aria-multiselectable": !!multiple,
    className: (0, import_classnames3.default)(className, "rw-list"),
    role: (_elementProps$role = elementProps.role) != null ? _elementProps$role : "listbox",
    children: import_react12.default.Children.count(items) ? items : import_react12.default.createElement("div", {
      className: "rw-list-empty"
    }, emptyList())
  });
  return renderList ? renderList(rootProps) : import_react12.default.createElement("div", rootProps);
});
List.displayName = "List";
List.propTypes = propTypes3;
var List_default = List;

// node_modules/react-widgets/esm/A11y.js
var import_react13 = __toESM(require_react());
var setActiveDescendant = (ref, activeId) => {
  if (!ref)
    return;
  ref.removeAttribute("aria-activedescendant");
  if (activeId)
    ref.setAttribute("aria-activedescendant", activeId);
};
var useActiveDescendant = (ref, id, visible, deps) => {
  (0, import_react13.useEffect)(() => {
    setActiveDescendant(ref.current, visible ? id : "");
  }, [ref, id, visible, ...deps]);
};

// node_modules/react-widgets/esm/Accessors.js
var import_react14 = __toESM(require_react());
var dataValue = (dataItem2, field) => {
  if (typeof field === "function")
    return field(dataItem2);
  if (dataItem2 == null)
    return dataItem2;
  if (typeof field === "string" && typeof dataItem2 === "object" && field in dataItem2)
    return dataItem2[field];
  return dataItem2;
};
var dataText = (dataItem2, textField) => {
  const value = dataValue(dataItem2, textField);
  return value == null ? "" : String(value);
};
function valueMatcher(a, b, dataKey) {
  return dataValue(a, dataKey) === dataValue(b, dataKey);
}
function dataIndexOf(data, value, dataKey) {
  const valueDataKey = dataValue(value, dataKey);
  let idx = -1;
  while (++idx < data.length) {
    const datum = data[idx];
    if (datum === value || dataValue(datum, dataKey) === valueDataKey)
      return idx;
  }
  return -1;
}
function dataItem(data, value, dataKey) {
  const idx = dataIndexOf(data, value, dataKey);
  return idx !== -1 ? data[idx] : value;
}
var useAccessors = (textField, dataKey) => {
  return (0, import_react14.useMemo)(() => ({
    text: (item) => dataText(item, textField),
    value: (item) => dataValue(item, dataKey),
    indexOf: (data, value) => dataIndexOf(data, value, dataKey),
    matches: (a, b) => valueMatcher(a, b, dataKey),
    findOrSelf: (data, value) => dataItem(data, value, dataKey),
    includes: (data, value) => dataIndexOf(data, value, dataKey) !== -1
  }), [textField, dataKey]);
};

// node_modules/react-widgets/esm/Filter.js
var import_react15 = __toESM(require_react());
var presets = {
  eq: (a, b) => a === b,
  contains: (a, b) => a.indexOf(b) !== -1,
  startsWith: (a, b) => a.lastIndexOf(b, 0) === 0
};
function normalizeFilter(filter, textField) {
  if (filter === false)
    return null;
  if (typeof filter === "function")
    return filter;
  const filterPreset = presets[filter === true ? "startsWith" : filter || "eq"];
  return (item, searchTerm) => {
    let textValue = dataText(item, textField);
    return filterPreset(textValue.toLowerCase(), searchTerm.toLowerCase());
  };
}
function useFilteredData(data, filterer, searchTerm = "", textAccessor) {
  return (0, import_react15.useMemo)(() => {
    const filter = normalizeFilter(filterer, textAccessor);
    if (!filter || !searchTerm.trim())
      return data;
    return data.filter((item, idx) => filter(item, searchTerm, idx));
  }, [data, filterer, searchTerm, textAccessor]);
}

export {
  FocusListContext,
  useFocusList,
  ListOption_default,
  useWillUnmount,
  List_default,
  useActiveDescendant,
  useAccessors,
  presets,
  useFilteredData
};
//# sourceMappingURL=chunk-TOMEQ7SX.js.map
