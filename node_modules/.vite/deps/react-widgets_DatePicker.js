import {
  InputAddon_default
} from "./chunk-QLGIIAPK.js";
import {
  useAutoFocus
} from "./chunk-XTTWT534.js";
import {
  Popup_default,
  chunk,
  qsa,
  transitionEnd,
  useDropdownToggle
} from "./chunk-UHMEWT6U.js";
import {
  Button_default,
  Input_default
} from "./chunk-FXI54CGI.js";
import {
  dates_default,
  isNullOrInvalid,
  useLocalizer
} from "./chunk-C5XAPTI4.js";
import {
  WidgetPicker_default,
  Widget_default,
  calendar,
  caretDown,
  chevronLeft,
  chevronRight,
  notify,
  require_classnames,
  times,
  useEventCallback,
  useEventListener,
  useFirstFocusedRender,
  useFocusManager,
  useInstanceId,
  useUncontrolled,
  useUncontrolledProp
} from "./chunk-JMLJIJD3.js";
import {
  require_prop_types
} from "./chunk-4LVSZ64H.js";
import "./chunk-XBHG3ID7.js";
import {
  require_react
} from "./chunk-YSDLPTTY.js";
import {
  __toESM
} from "./chunk-ZS7NZCD4.js";

// node_modules/react-widgets/esm/DatePicker.js
var import_classnames7 = __toESM(require_classnames());
var import_prop_types4 = __toESM(require_prop_types());
var import_react13 = __toESM(require_react());

// node_modules/react-widgets/esm/Calendar.js
var import_classnames5 = __toESM(require_classnames());
var import_prop_types2 = __toESM(require_prop_types());
var import_react8 = __toESM(require_react());

// node_modules/react-widgets/esm/CalendarHeader.js
var import_react = __toESM(require_react());

// node_modules/react-widgets/esm/CalendarButton.js
var import_classnames = __toESM(require_classnames());
var React = __toESM(require_react());
var _excluded = ["className"];
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function CalendarButton(_ref) {
  let {
    className
  } = _ref, props = _objectWithoutPropertiesLoose(_ref, _excluded);
  return React.createElement(Button_default, _extends({}, props, {
    tabIndex: void 0,
    className: (0, import_classnames.default)(className, "rw-calendar-btn")
  }));
}
var CalendarButton_default = CalendarButton;

// node_modules/react-widgets/esm/CalendarHeader.js
function CalendarHeader({
  localizer,
  label,
  labelId,
  onMoveRight,
  onMoveToday,
  onMoveLeft,
  onViewChange,
  prevDisabled,
  todayDisabled,
  upDisabled,
  nextDisabled,
  navigatePrevIcon = chevronLeft,
  navigateNextIcon = chevronRight
}) {
  return import_react.default.createElement("div", {
    className: "rw-calendar-header"
  }, import_react.default.createElement(CalendarButton_default, {
    id: labelId,
    onClick: onViewChange,
    className: "rw-calendar-btn-view",
    disabled: upDisabled,
    "aria-live": "polite",
    "aria-atomic": "true"
  }, label, " ", caretDown), import_react.default.createElement(CalendarButton_default, {
    className: "rw-calendar-btn-left",
    onClick: onMoveLeft,
    disabled: prevDisabled,
    label: localizer.messages.moveBack(),
    icon: navigatePrevIcon
  }), import_react.default.createElement(CalendarButton_default, {
    className: "rw-calendar-btn-today",
    disabled: todayDisabled,
    onClick: onMoveToday
  }, localizer.messages.moveToday()), import_react.default.createElement(CalendarButton_default, {
    className: "rw-calendar-btn-right",
    onClick: onMoveRight,
    disabled: nextDisabled,
    label: localizer.messages.moveForward(),
    icon: navigateNextIcon
  }));
}
var CalendarHeader_default = CalendarHeader;

// node_modules/react-widgets/esm/Century.js
var import_react3 = __toESM(require_react());

// node_modules/react-widgets/esm/CalendarView.js
var import_classnames2 = __toESM(require_classnames());
var import_react2 = __toESM(require_react());
function _extends2() {
  _extends2 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
function clamp(date, min, max) {
  return dates_default.max(dates_default.min(date, max), min);
}
function CalendarView({
  className,
  focusedItem,
  onKeyDown,
  children,
  "aria-labelledby": labelledby
}) {
  const ref = (0, import_react2.useRef)(null);
  const [focusEvents, focused] = useFocusManager(ref);
  (0, import_react2.useEffect)(() => {
    var _node$querySelector;
    const node = ref.current;
    if (!node || !focused)
      return;
    (_node$querySelector = node.querySelector(".rw-cell[tabindex]")) == null ? void 0 : _node$querySelector.focus();
  }, [focusedItem, focused, ref]);
  return import_react2.default.createElement("div", _extends2({
    role: "grid",
    ref,
    tabIndex: -1
  }, focusEvents, {
    onKeyDown,
    "aria-labelledby": labelledby,
    className: (0, import_classnames2.default)(className, "rw-nav-view", "rw-calendar-grid")
  }), children);
}
function CalendarViewCell({
  onChange,
  min,
  max,
  date,
  unit,
  disabled,
  selected,
  focusedItem,
  viewUnit,
  children,
  label
}) {
  const isEqual = (nextDate) => dates_default.eq(date, nextDate, unit);
  const isEmpty = !dates_default.inRange(date, min, max, unit);
  const isDisabled = disabled || isEmpty;
  const isFocused = !disabled && !isEmpty && isEqual(focusedItem);
  const isSelected = selected && isEqual(selected);
  const isOffView = date && focusedItem && viewUnit && dates_default[viewUnit](date) !== dates_default[viewUnit](focusedItem);
  const handleChange = () => {
    onChange(clamp(date, min, max));
  };
  return import_react2.default.createElement("div", {
    role: "gridcell",
    title: label,
    "aria-label": label,
    "aria-readonly": disabled,
    "aria-selected": Boolean(isSelected),
    tabIndex: isFocused ? 0 : void 0,
    onClick: !isDisabled ? handleChange : void 0,
    className: (0, import_classnames2.default)(
      "rw-cell",
      // isNow && 'rw-now',
      isDisabled && "rw-state-disabled",
      isEmpty && "rw-cell-not-allowed",
      isOffView && "rw-cell-off-range",
      isSelected && "rw-state-selected"
    )
  }, import_react2.default.createElement("span", {
    "aria-hidden": true
  }, children));
}
CalendarView.Body = (props) => import_react2.default.createElement("div", _extends2({
  role: "rowgroup",
  className: "rw-calendar-body"
}, props));
CalendarView.Row = (props) => import_react2.default.createElement("div", _extends2({
  role: "row",
  className: "rw-calendar-row"
}, props));
CalendarView.Cell = CalendarViewCell;
var CalendarView_default = CalendarView;

// node_modules/react-widgets/esm/Century.js
var _excluded2 = ["focusedItem", "disabled", "onChange", "value", "localizer", "min", "max"];
function _extends3() {
  _extends3 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends3.apply(this, arguments);
}
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function CenturyView(_ref) {
  let {
    focusedItem,
    disabled,
    onChange,
    value,
    localizer,
    min,
    max
  } = _ref, props = _objectWithoutPropertiesLoose2(_ref, _excluded2);
  const chunks = (0, import_react3.useMemo)(() => chunk(getCenturyDecades(focusedItem), 4), [focusedItem]);
  return import_react3.default.createElement(CalendarView_default, _extends3({}, props, {
    focusedItem
  }), import_react3.default.createElement(CalendarView_default.Body, null, chunks.map((row, rowIdx) => import_react3.default.createElement(CalendarView_default.Row, {
    key: rowIdx
  }, row.map((date, colIdx) => {
    let label = localizer.formatDate(dates_default.startOf(date, "decade"), "decade");
    return import_react3.default.createElement(CalendarView_default.Cell, {
      key: colIdx,
      unit: "decade",
      viewUnit: "century",
      label,
      date,
      min,
      max,
      onChange,
      focusedItem,
      selected: value,
      disabled
    }, label);
  })))));
}
function getCenturyDecades(_date) {
  let days = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
  let date = dates_default.add(dates_default.startOf(_date, "century"), -20, "year");
  return days.map(() => date = dates_default.add(date, 10, "year"));
}
var Century_default = CenturyView;

// node_modules/react-widgets/esm/Decade.js
var import_react4 = __toESM(require_react());
var _excluded3 = ["focusedItem", "disabled", "onChange", "value", "localizer", "min", "max"];
function _extends4() {
  _extends4 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends4.apply(this, arguments);
}
function _objectWithoutPropertiesLoose3(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function DecadeView(_ref) {
  let {
    focusedItem,
    disabled,
    onChange,
    value,
    localizer,
    min,
    max
  } = _ref, props = _objectWithoutPropertiesLoose3(_ref, _excluded3);
  const chunks = (0, import_react4.useMemo)(() => chunk(getDecadeYears(focusedItem), 4), [focusedItem]);
  return import_react4.default.createElement(CalendarView_default, _extends4({}, props, {
    focusedItem
  }), import_react4.default.createElement(CalendarView_default.Body, null, chunks.map((row, rowIdx) => import_react4.default.createElement(CalendarView_default.Row, {
    key: rowIdx
  }, row.map((date, colIdx) => {
    let label = localizer.formatDate(date, "year");
    return import_react4.default.createElement(CalendarView_default.Cell, {
      key: colIdx,
      unit: "year",
      viewUnit: "decade",
      label,
      date,
      min,
      max,
      onChange,
      focusedItem,
      selected: value,
      disabled
    }, label);
  })))));
}
function getDecadeYears(_date) {
  let days = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
  let date = dates_default.add(dates_default.startOf(_date, "decade"), -2, "year");
  return days.map(() => date = dates_default.add(date, 1, "year"));
}
var Decade_default = DecadeView;

// node_modules/react-widgets/esm/Month.js
var import_classnames3 = __toESM(require_classnames());
var import_react5 = __toESM(require_react());
var _excluded4 = ["className", "focusedItem", "disabled", "onChange", "value", "min", "max", "localizer", "renderDay"];
function _extends5() {
  _extends5 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends5.apply(this, arguments);
}
function _objectWithoutPropertiesLoose4(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function visibleDays(date, weekStart) {
  let current = dates_default.startOf(dates_default.startOf(date, "month"), "week", weekStart);
  let last2 = dates_default.endOf(dates_default.endOf(date, "month"), "week", weekStart);
  let days = [];
  while (dates_default.lte(current, last2, "day")) {
    days.push(current);
    current = dates_default.add(current, 1, "day");
  }
  return days;
}
function MonthView(_ref) {
  let {
    className,
    focusedItem,
    disabled,
    onChange,
    value,
    min,
    max,
    localizer,
    renderDay
  } = _ref, props = _objectWithoutPropertiesLoose4(_ref, _excluded4);
  let month = visibleDays(focusedItem, localizer.firstOfWeek());
  let rows = chunk(month, 7);
  return import_react5.default.createElement(CalendarView_default, _extends5({}, props, {
    focusedItem,
    className: (0, import_classnames3.default)(className, "rw-calendar-month")
  }), import_react5.default.createElement("div", {
    role: "rowgroup",
    className: "rw-calendar-head"
  }, import_react5.default.createElement(CalendarView_default.Row, {
    className: "rw-calendar-row"
  }, rows[0].map((date, idx) => import_react5.default.createElement("div", {
    role: "columnheader",
    className: "rw-head-cell",
    key: idx
  }, localizer.formatDate(date, "weekday"))))), import_react5.default.createElement(CalendarView_default.Body, null, rows.map((row, rowIdx) => import_react5.default.createElement(CalendarView_default.Row, {
    key: rowIdx
  }, row.map((date, colIdx) => {
    let formattedDate = localizer.formatDate(date, "dayOfMonth");
    let label = localizer.formatDate(date, "date");
    return import_react5.default.createElement(CalendarView_default.Cell, {
      key: colIdx,
      label,
      date,
      min,
      max,
      unit: "day",
      viewUnit: "month",
      onChange,
      focusedItem,
      selected: value,
      disabled
    }, renderDay ? renderDay({
      date,
      label: formattedDate
    }) : formattedDate);
  })))));
}
var Month_default = MonthView;

// node_modules/react-widgets/esm/SlideTransitionGroup.js
var import_classnames4 = __toESM(require_classnames());
var import_prop_types = __toESM(require_prop_types());
var import_react6 = __toESM(require_react());
var _excluded5 = ["direction", "children", "onTransitionEnd"];
function _extends6() {
  _extends6 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends6.apply(this, arguments);
}
function _objectWithoutPropertiesLoose5(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var DirectionPropType = import_prop_types.default.oneOf(["left", "right", "top", "bottom"]);
var prefix = "rw-calendar-transition";
var active = "rw-calendar-transition-active";
var next = "rw-calendar-transition-next";
var prev = "rw-calendar-transition-prev";
var clone = (el, cls) => el && import_react6.default.cloneElement(el, {
  className: (0, import_classnames4.default)(el.props.className, prefix, cls)
});
var SlideTransitionGroup = class extends import_react6.default.Component {
  constructor(args) {
    super(args);
    this.handleTransitionEnd = (hadFocus) => {
      this.isTransitioning = false;
      let current = this.container.current.lastChild;
      if (this.props.onTransitionEnd)
        this.props.onTransitionEnd(current, hadFocus);
    };
    this.current = this.props.children;
    this.container = import_react6.default.createRef();
    this.state = {
      prevClasses: "",
      currentClasses: ""
    };
  }
  componentDidUpdate() {
    if (!this.flush || this.isTransitioning)
      return;
    this.flush = false;
    this.isTransitioning = true;
    let previous = this.container.current.firstChild;
    const hadFocus = document.activeElement && previous.contains(document.activeElement);
    this.setState({
      prevClasses: "",
      currentClasses: next
    }, () => {
      let current = this.container.current.lastChild;
      current.clientHeight;
      this.setState({
        prevClasses: prev,
        currentClasses: (0, import_classnames4.default)(next, active)
      }, () => {
        transitionEnd(current, () => {
          this.prev = null;
          if (this.current.key !== this.props.children.key) {
            this.current = this.props.children;
          }
          this.setState({
            prevClasses: "",
            currentClasses: ""
          }, () => this.handleTransitionEnd(hadFocus));
        });
      });
    });
  }
  render() {
    let _this$props = this.props, {
      direction,
      children
    } = _this$props, props = _objectWithoutPropertiesLoose5(_this$props, _excluded5);
    if (!this.isTransitioning) {
      if (this.current.key !== children.key) {
        this.prev = this.current;
        this.flush = true;
      }
      this.current = children;
    }
    let {
      prevClasses,
      currentClasses
    } = this.state;
    return import_react6.default.createElement("div", _extends6({}, props, {
      ref: this.container,
      className: (0, import_classnames4.default)(`rw-calendar-transition-group`, direction === "top" && "rw-calendar-transition-top", direction === "right" && "rw-calendar-transition-right", direction === "bottom" && "rw-calendar-transition-bottom", direction === "left" && "rw-calendar-transition-left")
    }), clone(this.prev, prevClasses), clone(this.current, currentClasses));
  }
};
SlideTransitionGroup.defaultProps = {
  direction: "left"
};
SlideTransitionGroup.propTypes = {
  direction: DirectionPropType,
  onTransitionEnd: import_prop_types.default.func
};
var SlideTransitionGroup_default = SlideTransitionGroup;

// node_modules/react-widgets/esm/Year.js
var import_react7 = __toESM(require_react());
var _excluded6 = ["focusedItem", "disabled", "onChange", "value", "min", "localizer", "max"];
function _extends7() {
  _extends7 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends7.apply(this, arguments);
}
function _objectWithoutPropertiesLoose6(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var months = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
function monthsInYear(year) {
  let date = new Date(year, 0, 1);
  return months.map((i) => dates_default.month(date, i));
}
function YearView(_ref) {
  let {
    focusedItem,
    disabled,
    onChange,
    value,
    min,
    localizer,
    max
  } = _ref, props = _objectWithoutPropertiesLoose6(_ref, _excluded6);
  let months2 = monthsInYear(dates_default.year(focusedItem));
  return import_react7.default.createElement(CalendarView_default, _extends7({}, props, {
    focusedItem
  }), import_react7.default.createElement(CalendarView_default.Body, null, chunk(months2, 4).map((row, rowIdx) => import_react7.default.createElement(CalendarView_default.Row, {
    key: rowIdx
  }, row.map((date, colIdx) => {
    let label = localizer.formatDate(date, "header");
    return import_react7.default.createElement(CalendarView_default.Cell, {
      key: colIdx,
      label,
      date,
      min,
      max,
      unit: "month",
      viewUnit: "year",
      onChange,
      focusedItem,
      selected: value,
      disabled
    }, localizer.formatDate(date, "month"));
  })))));
}
var Year_default = YearView;

// node_modules/react-widgets/esm/Calendar.js
var _excluded7 = ["id", "autoFocus", "bordered", "views", "tabIndex", "disabled", "readOnly", "className", "value", "defaultValue", "onChange", "currentDate", "defaultCurrentDate", "onCurrentDateChange", "min", "max", "view", "defaultView", "onViewChange", "onKeyDown", "onNavigate", "renderDay", "messages", "formats"];
function _extends8() {
  _extends8 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends8.apply(this, arguments);
}
function _objectWithoutPropertiesLoose7(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var last = (a) => a[a.length - 1];
var CELL_CLASSNAME = "rw-cell";
var FOCUSED_CELL_SELECTOR = `.${CELL_CLASSNAME}[tabindex]`;
var MIN = new Date(1900, 0, 1);
var MAX = new Date(2099, 11, 31);
var VIEW_OPTIONS = ["month", "year", "decade", "century"];
var VIEW_UNIT = {
  month: "day",
  year: "month",
  decade: "year",
  century: "decade"
};
var VIEW = {
  month: Month_default,
  year: Year_default,
  decade: Decade_default,
  century: Century_default
};
var ARROWS_TO_DIRECTION = {
  ArrowDown: "DOWN",
  ArrowUp: "UP",
  ArrowRight: "RIGHT",
  ArrowLeft: "LEFT"
};
var OPPOSITE_DIRECTION = {
  LEFT: "RIGHT",
  RIGHT: "LEFT"
};
var MULTIPLIER = {
  year: 1,
  decade: 10,
  century: 100
};
function inRangeValue(_value, min, max) {
  let value = dateOrNull(_value);
  if (value === null)
    return value;
  return dates_default.max(dates_default.min(value, max), min);
}
var propTypes = {
  /**
   * @example ['disabled', ['new Date()']]
   */
  disabled: import_prop_types2.default.bool,
  /**
   * @example ['readOnly', ['new Date()']]
   */
  readOnly: import_prop_types2.default.bool,
  /**
   * @example ['onChangePicker', [ ['new Date()'] ]]
   */
  onChange: import_prop_types2.default.func,
  /**
   * The selected Date.
   *
   * ```tsx live
   * import { Calendar } from 'react-widgets';
   *
   * <Calendar value={new Date()} />
   * ```
   * @example false
   */
  value: import_prop_types2.default.instanceOf(Date),
  /**
   * The minimum date that the Calendar can navigate from.
   *
   * @example ['prop', ['min', 'new Date()']]
   */
  min: import_prop_types2.default.instanceOf(Date),
  /**
   * The maximum date that the Calendar can navigate to.
   *
   * @example ['prop', ['max', 'new Date()']]
   */
  max: import_prop_types2.default.instanceOf(Date),
  /**
   * Default current date at which the calendar opens. If none is provided, opens at today's date or the `value` date (if any).
   */
  currentDate: import_prop_types2.default.instanceOf(Date),
  /**
   * Change event Handler that is called when the currentDate is changed. The handler is called with the currentDate object.
   */
  onCurrentDateChange: import_prop_types2.default.func,
  /** Specify the navigate into the past header icon */
  navigatePrevIcon: import_prop_types2.default.node,
  /** Specify the navigate into the future header icon */
  navigateNextIcon: import_prop_types2.default.node,
  /**
   * Controls the currently displayed calendar view. Use `defaultView` to set a unique starting view.
   *
   * @type {("month"|"year"|"decade"|"century")}
   * @controllable onViewChange
   */
  view(props, ...args) {
    return import_prop_types2.default.oneOf(props.views || VIEW_OPTIONS)(props, ...args);
  },
  /**
   * Defines a list of views the Calendar can traverse through, starting with the
   * first in the list to the last.
   *
   * @type array<"month"|"year"|"decade"|"century">
   */
  views: import_prop_types2.default.arrayOf(import_prop_types2.default.oneOf(VIEW_OPTIONS)),
  /**
   * A callback fired when the `view` changes.
   *
   * @controllable view
   */
  onViewChange: import_prop_types2.default.func,
  /**
   * Callback fired when the Calendar navigates between views, or forward and backwards in time.
   *
   * @type function(date: ?Date, direction: string, view: string)
   */
  onNavigate: import_prop_types2.default.func,
  culture: import_prop_types2.default.string,
  autoFocus: import_prop_types2.default.bool,
  /**
   * Show or hide the Calendar footer.
   *
   * @example ['prop', ['footer', true]]
   */
  footer: import_prop_types2.default.bool,
  /**
   * Provide a custom component to render the days of the month. The Component is provided the following props
   *
   * - `date`: a `Date` object for the day of the month to render
   * - `label`: a formatted `string` of the date to render. To adjust the format of the `label` string use the `dateFormat` prop, listed below.
   */
  renderDay: import_prop_types2.default.func,
  formats: import_prop_types2.default.shape({
    /**
     * A formatter for the header button of the month view.
     *
     * @example ['dateFormat', ['headerFormat', "{ date: 'medium' }"]]
     */
    header: import_prop_types2.default.any,
    /**
     * A formatter for the Calendar footer, formats today's Date as a string.
     *
     * @example ['dateFormat', ['footerFormat', "{ date: 'medium' }", "date => 'Today is: ' + formatter(date)"]]
     */
    footer: import_prop_types2.default.any,
    /**
     * A formatter calendar days of the week, the default formats each day as a Narrow name: "Mo", "Tu", etc.
     *
     * @example ['prop', { day: "day => \n['ðŸŽ‰', 'M', 'T','W','Th', 'F', 'ðŸŽ‰'][day.getDay()]" }]
     */
    day: import_prop_types2.default.any,
    /**
     * A formatter for day of the month
     *
     * @example ['prop', { date: "dt => String(dt.getDate())" }]
     */
    date: import_prop_types2.default.any,
    /**
     * A formatter for month name.
     *
     * @example ['dateFormat', ['monthFormat', "{ raw: 'MMMM' }", null, { defaultView: '"year"' }]]
     */
    month: import_prop_types2.default.any,
    /**
     * A formatter for month name.
     *
     * @example ['dateFormat', ['yearFormat', "{ raw: 'yy' }", null, { defaultView: '"decade"' }]]
     */
    year: import_prop_types2.default.any,
    /**
     * A formatter for decade, the default formats the first and last year of the decade like: 2000 - 2009.
     */
    decade: import_prop_types2.default.any,
    /**
     * A formatter for century, the default formats the first and last year of the century like: 1900 - 1999.
     */
    century: import_prop_types2.default.any
  }),
  messages: import_prop_types2.default.shape({
    moveBack: import_prop_types2.default.string,
    moveForward: import_prop_types2.default.string
  }),
  onKeyDown: import_prop_types2.default.func,
  /** @ignore */
  tabIndex: import_prop_types2.default.any
};
var useViewState = (views, view = views[0], currentDate) => {
  const lastView = (0, import_react8.useRef)(view);
  const lastDate = (0, import_react8.useRef)(currentDate);
  let slideDirection;
  if (view !== lastView.current) {
    slideDirection = views.indexOf(lastView.current) > views.indexOf(view) ? "top" : "bottom";
  } else if (lastDate.current !== currentDate) {
    slideDirection = dates_default.gt(currentDate, lastDate.current) ? "left" : "right";
  }
  (0, import_react8.useEffect)(() => {
    lastDate.current = currentDate;
    lastView.current = view;
  });
  return slideDirection;
};
function Calendar(_ref) {
  let {
    id,
    autoFocus,
    bordered = true,
    views = VIEW_OPTIONS,
    tabIndex = 0,
    disabled,
    readOnly,
    className,
    value,
    defaultValue,
    onChange,
    currentDate: pCurrentDate,
    defaultCurrentDate,
    onCurrentDateChange,
    min = MIN,
    max = MAX,
    view,
    defaultView = views[0],
    onViewChange,
    onKeyDown,
    onNavigate,
    renderDay,
    messages,
    formats
  } = _ref, elementProps = _objectWithoutPropertiesLoose7(_ref, _excluded7);
  const [currentValue, handleChange] = useUncontrolledProp(value, defaultValue, onChange);
  const [currentDate, handleCurrentDateChange] = useUncontrolledProp(pCurrentDate, defaultCurrentDate || currentValue || /* @__PURE__ */ new Date(), onCurrentDateChange);
  const [currentView, handleViewChange] = useUncontrolledProp(view, defaultView, onViewChange);
  const localizer = useLocalizer(messages, formats);
  const ref = (0, import_react8.useRef)(null);
  const viewId = useInstanceId(id, "_calendar");
  const labelId = useInstanceId(id, "_calendar_label");
  useAutoFocus(!!autoFocus, ref);
  const slideDirection = useViewState(views, currentView, currentDate);
  const [, focused] = useFocusManager(ref, {
    disabled
  }, {
    willHandle() {
      if (tabIndex == -1)
        return false;
    }
  });
  const lastValue = (0, import_react8.useRef)(currentValue);
  (0, import_react8.useEffect)(() => {
    const inValue = inRangeValue(currentValue, min, max);
    const last2 = lastValue.current;
    lastValue.current = currentValue;
    if (!dates_default.eq(inValue, dateOrNull(last2), VIEW_UNIT[currentView]))
      maybeSetCurrentDate(inValue);
  });
  const isDisabled = disabled || readOnly;
  const handleViewChangeImpl = () => {
    navigate("UP");
  };
  const handleMoveBack = () => {
    navigate("LEFT");
  };
  const handleMoveForward = () => {
    navigate("RIGHT");
  };
  const handleDateChange = (date) => {
    if (views[0] === currentView) {
      maybeSetCurrentDate(date);
      notify(handleChange, [date]);
      focus();
      return;
    }
    navigate("DOWN", date);
  };
  const handleMoveToday = () => {
    let date = /* @__PURE__ */ new Date();
    let firstView = views[0];
    notify(onChange, [date]);
    if (dates_default.inRange(date, min, max, firstView)) {
      focus();
      maybeSetCurrentDate(date);
      notify(handleViewChange, [firstView]);
    }
  };
  const handleKeyDown = (e) => {
    let ctrl = e.ctrlKey || e.metaKey;
    let key2 = e.key;
    let direction = ARROWS_TO_DIRECTION[key2];
    let unit = VIEW_UNIT[currentView];
    if (key2 === "Enter") {
      e.preventDefault();
      return handleDateChange(currentDate);
    }
    if (direction) {
      if (ctrl) {
        e.preventDefault();
        navigate(direction);
      } else {
        const isRTL = getComputedStyle(e.currentTarget).getPropertyValue("direction") === "rtl";
        if (isRTL && direction in OPPOSITE_DIRECTION)
          direction = OPPOSITE_DIRECTION[direction];
        let nextDate2 = Calendar.move(currentDate, min, max, currentView, direction);
        if (!dates_default.eq(currentDate, nextDate2, unit)) {
          e.preventDefault();
          if (dates_default.gt(nextDate2, currentDate, currentView))
            navigate("RIGHT", nextDate2);
          else if (dates_default.lt(nextDate2, currentDate, currentView))
            navigate("LEFT", nextDate2);
          else
            maybeSetCurrentDate(nextDate2);
        }
      }
    }
    notify(onKeyDown, [e]);
  };
  function navigate(direction, date) {
    let nextView = currentView;
    let slideDir = direction === "LEFT" || direction === "UP" ? "right" : "left";
    if (direction === "UP")
      nextView = views[views.indexOf(currentView) + 1] || nextView;
    if (direction === "DOWN")
      nextView = views[views.indexOf(currentView) - 1] || nextView;
    if (!date)
      date = ["LEFT", "RIGHT"].indexOf(direction) !== -1 ? nextDate(direction) : currentDate;
    if (dates_default.inRange(date, min, max, nextView)) {
      notify(onNavigate, [date, slideDir, nextView]);
      maybeSetCurrentDate(date);
      notify(handleViewChange, [nextView]);
    }
  }
  const focus = () => {
    var _ref$current;
    const node = (_ref$current = ref.current) == null ? void 0 : _ref$current.querySelector(FOCUSED_CELL_SELECTOR);
    node == null ? void 0 : node.focus();
  };
  const moveFocus = (node, hadFocus) => {
    let current = document.activeElement;
    if (hadFocus && (!current || !node.contains(current))) {
      node.focus();
    }
  };
  function maybeSetCurrentDate(date) {
    let inRangeDate = inRangeValue(date ? new Date(date) : currentDate, min, max);
    if (date === currentDate || dates_default.eq(inRangeDate, dateOrNull(currentDate), VIEW_UNIT[currentView]))
      return;
    notify(handleCurrentDateChange, [inRangeDate]);
  }
  function nextDate(direction) {
    let method = direction === "LEFT" ? "subtract" : "add";
    let unit = currentView === "month" ? currentView : "year";
    let multi = MULTIPLIER[currentView] || 1;
    return dates_default[method](currentDate, 1 * multi, unit);
  }
  function getHeaderLabel() {
    switch (currentView) {
      case "month":
        return localizer.formatDate(currentDate, "header");
      case "year":
        return localizer.formatDate(currentDate, "year");
      case "decade":
        return localizer.formatDate(dates_default.startOf(currentDate, "decade"), "decade");
      case "century":
        return localizer.formatDate(dates_default.startOf(currentDate, "century"), "century");
    }
  }
  let View = VIEW[currentView];
  let todayNotInRange = !dates_default.inRange(/* @__PURE__ */ new Date(), min, max, currentView);
  let key = currentView + "_" + dates_default[currentView](currentDate);
  const prevDisabled = isDisabled || !dates_default.inRange(nextDate("LEFT"), min, max, currentView);
  const nextDisabled = isDisabled || !dates_default.inRange(nextDate("RIGHT"), min, max, currentView);
  return import_react8.default.createElement(Widget_default, _extends8({}, elementProps, {
    role: "group",
    ref,
    focused,
    disabled,
    readOnly,
    tabIndex,
    className: (0, import_classnames5.default)(className, "rw-calendar", bordered && "rw-calendar-contained")
  }), import_react8.default.createElement(CalendarHeader_default, {
    label: getHeaderLabel(),
    labelId,
    localizer,
    upDisabled: isDisabled || currentView === last(views),
    prevDisabled,
    todayDisabled: isDisabled || todayNotInRange,
    nextDisabled,
    onViewChange: handleViewChangeImpl,
    onMoveLeft: handleMoveBack,
    onMoveRight: handleMoveForward,
    onMoveToday: handleMoveToday
  }), import_react8.default.createElement(Calendar.Transition, {
    direction: slideDirection,
    onTransitionEnd: moveFocus
  }, import_react8.default.createElement(View, {
    key,
    min,
    max,
    id: viewId,
    value: currentValue,
    localizer,
    disabled: isDisabled,
    focusedItem: currentDate,
    onChange: handleDateChange,
    onKeyDown: handleKeyDown,
    "aria-labelledby": labelId,
    renderDay
  })));
}
function dateOrNull(dt) {
  if (dt && !isNaN(dt.getTime()))
    return dt;
  return null;
}
Calendar.displayName = "Calendar";
Calendar.propTypes = propTypes;
Calendar.Transition = SlideTransitionGroup_default;
Calendar.move = (date, min, max, view, direction) => {
  let isMonth = view === "month";
  let isUpOrDown = direction === "UP" || direction === "DOWN";
  let rangeUnit = view && VIEW_UNIT[view];
  let addUnit = isMonth && isUpOrDown ? "week" : VIEW_UNIT[view];
  let amount = isMonth || !isUpOrDown ? 1 : 4;
  let newDate;
  if (direction === "UP" || direction === "LEFT")
    amount *= -1;
  newDate = dates_default.add(date, amount, addUnit);
  return dates_default.inRange(newDate, min, max, rangeUnit) ? newDate : date;
};
var Calendar_default = Calendar;

// node_modules/react-widgets/esm/DatePickerInput.js
var import_react9 = __toESM(require_react());
var _excluded8 = ["value", "formatter", "editing", "editFormat", "displayFormat", "localizer", "parse", "onChange", "onBlur", "disabled", "readOnly"];
function _extends9() {
  _extends9 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends9.apply(this, arguments);
}
function _objectWithoutPropertiesLoose8(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var DatePickerInput = import_react9.default.forwardRef((_ref, ref) => {
  let {
    value,
    formatter,
    editing,
    editFormat,
    displayFormat,
    localizer,
    parse,
    onChange,
    onBlur,
    disabled,
    readOnly
  } = _ref, props = _objectWithoutPropertiesLoose8(_ref, _excluded8);
  const needsFlush = (0, import_react9.useRef)(false);
  const nextTextValue = (0, import_react9.useMemo)(() => value instanceof Date && isValid(value) ? localizer.formatDate(value, formatter, editing ? editFormat : displayFormat) : "", [value, formatter, localizer, displayFormat, editing, editFormat]);
  const [prevValue, setPrevValue] = (0, import_react9.useState)(nextTextValue);
  const [textValue, setTextValue] = (0, import_react9.useState)(nextTextValue);
  if (prevValue !== nextTextValue) {
    setPrevValue(nextTextValue);
    setTextValue(nextTextValue);
  }
  const handleBlur = (event) => {
    if (onBlur)
      onBlur(event);
    if (needsFlush.current) {
      let date = parse(event.target.value);
      const dateIsInvalid = event.target.value != "" && isNullOrInvalid(date);
      if (dateIsInvalid) {
        setTextValue("");
      }
      needsFlush.current = false;
      setPrevValue(null);
      onChange(date, event.target.value);
    }
  };
  const handleChange = ({
    target
  }) => {
    needsFlush.current = true;
    setTextValue(target.value);
  };
  return import_react9.default.createElement(Input_default, _extends9({}, props, {
    type: "text",
    ref,
    className: "rw-widget-input",
    value: textValue,
    disabled,
    readOnly,
    onChange: handleChange,
    onBlur: handleBlur
  }));
});
DatePickerInput.displayName = "DatePickerInput";
var DatePickerInput_default = DatePickerInput;
function isValid(d) {
  return !isNaN(d.getTime());
}

// node_modules/react-widgets/esm/TimeInput.js
var import_classnames6 = __toESM(require_classnames());
var import_prop_types3 = __toESM(require_prop_types());
var import_react11 = __toESM(require_react());

// node_modules/react-widgets/esm/DateTimePartInput.js
var import_react10 = __toESM(require_react());
var _excluded9 = ["value", "valueText", "pad", "placeholder", "min", "max", "emptyChar"];
function _extends10() {
  _extends10 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends10.apply(this, arguments);
}
function _objectWithoutPropertiesLoose9(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var padStart = (value, len, padding) => {
  let str = String(value != null ? value : "");
  while (str.length < len)
    str = padding + str;
  return str;
};
var DateTimePartInput = import_react10.default.forwardRef((_ref, ref) => {
  let {
    value,
    valueText = String(value != null ? value : ""),
    pad,
    placeholder,
    min,
    max,
    emptyChar
  } = _ref, props = _objectWithoutPropertiesLoose9(_ref, _excluded9);
  return import_react10.default.createElement("input", _extends10({}, props, {
    ref,
    "data-focusable": true,
    autoComplete: "off",
    role: "spinbutton",
    "aria-valuenow": value != null ? value : void 0,
    "aria-valuemin": min,
    "aria-valuemax": max,
    "aria-valuetext": valueText,
    "aria-disabled": props.disabled || props.readOnly,
    "arai-placeholder": placeholder,
    placeholder,
    className: "rw-time-part-input",
    value: placeholder && !value ? "" : padStart(value, pad || 0, value == null ? emptyChar : "0")
  }));
});
var DateTimePartInput_default = DateTimePartInput;

// node_modules/react-widgets/esm/TimeInput.js
var _excluded10 = ["value", "use12HourClock", "padValues", "emptyCharacter", "precision", "noClearButton", "hoursAddon", "minutesAddon", "secondsAddon", "millisecondsAddon", "className", "disabled", "readOnly", "datePart", "onChange", "onBlur", "onFocus"];
function _extends11() {
  _extends11 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends11.apply(this, arguments);
}
function _objectWithoutPropertiesLoose10(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var selectTextRange = (el) => {
  if (el instanceof HTMLInputElement)
    return el.select();
  const range = document.createRange();
  range.selectNodeContents(el);
  const selection = window.getSelection();
  if (selection) {
    selection.removeAllRanges();
    selection.addRange(range);
  }
};
var isEmptyValue = (p, precision) => p.hours == null && p.minutes == null && (precision != "seconds" && precision !== "milliseconds" || p.seconds == null) && (precision !== "milliseconds" || p.milliseconds == null);
var isPartialValue = (p, precision) => p.hours == null || p.minutes == null || (precision === "seconds" || precision === "milliseconds") && p.seconds == null || precision === "milliseconds" && p.milliseconds == null;
var getValueParts = (value, use12HourClock) => {
  let hours, minutes, seconds, milliseconds;
  let meridiem = "AM";
  if (value) {
    hours = value.getHours();
    if (use12HourClock) {
      meridiem = hours < 12 ? "AM" : "PM";
      hours = hours % 12 || 12;
    }
    minutes = value.getMinutes();
    seconds = value.getSeconds();
    milliseconds = value.getMilliseconds();
  }
  return {
    hours,
    minutes,
    seconds,
    milliseconds,
    meridiem
  };
};
var TEST_VALID = {
  hours: /^([1]?[0-9]|2[0-3])$/,
  hours12: /^(1[0-2]|0?[1-9])$/,
  minutes: /^([0-5]?\d)$/,
  seconds: /^([0-5]?\d)$/,
  milliseconds: /^(\d{1,3})$/
};
var TEST_COMPLETE = {
  hours: /^([3-9]|\d{2})$/,
  hours12: /^(\d{2}|[2-9])$/,
  minutes: /^(d{2}|[6-9])$/,
  seconds: /^(d{2}|[6-9])$/,
  milliseconds: /^(\d{3})$/
};
function testPart(value, part, use12HourClock, tests) {
  const key = part === "hours" && use12HourClock ? "hours12" : part;
  return tests[key].test(value);
}
var isValid2 = (value, part, use12HourClock) => testPart(value, part, use12HourClock, TEST_VALID);
var isComplete = (value, part, use12HourClock) => testPart(value, part, use12HourClock, TEST_COMPLETE);
var propTypes2 = {
  /**
   * @example ['valuePicker', [ ['new Date()'] ]]
   */
  value: import_prop_types3.default.instanceOf(Date),
  /**
   * @example ['onChangePicker', [ ['new Date()'] ]]
   */
  onChange: import_prop_types3.default.func,
  /**
   * The default date used to construct a new time when the `value` is empty
   *
   * @default new Date()
   **/
  datePart: import_prop_types3.default.instanceOf(Date),
  /**
   * Use a 12 hour clock (with AM/PM) instead of 24 hour one.
   * The configured localizer may provide a default value .
   **/
  use12HourClock: import_prop_types3.default.bool,
  /** Time part values will be padded by `0` */
  padValues: import_prop_types3.default.bool,
  /** The string character used to pad empty, or cleared values */
  emptyCharacter: import_prop_types3.default.string,
  /** Hide the input clear button */
  noClearButton: import_prop_types3.default.bool,
  /**
   * @example ['disabled', ['new Date()']]
   */
  disabled: import_prop_types3.default.bool,
  /**
   * @example ['readOnly', ['new Date()']]
   */
  readOnly: import_prop_types3.default.bool,
  /** Controls how precise of a time can be input **/
  precision: import_prop_types3.default.oneOf(["minutes", "seconds", "milliseconds"]).isRequired,
  /**
   * The seperator between hours and minutes
   * @default ':'
   */
  hoursAddon: import_prop_types3.default.node,
  /**
   * The seperator between hours and minutes
   * @default ':'
   */
  minutesAddon: import_prop_types3.default.node,
  /**
   * The seperator between hours and minutes
   * @default ':'
   */
  secondsAddon: import_prop_types3.default.node,
  /**
   * The seperator between hours and minutes
   * @default '.'
   */
  millisecondsAddon: import_prop_types3.default.node
};
var defaultProps = {
  hoursAddon: ":",
  padValues: true,
  precision: "minutes",
  emptyCharacter: "-"
};
function useTimePartState(value, use12HourClock) {
  const [state, setState] = (0, import_react11.useState)(() => ({
    value,
    use12HourClock,
    timeParts: getValueParts(value, use12HourClock)
  }));
  const setTimeParts = (0, import_react11.useCallback)((timeParts) => setState((s) => Object.assign({}, s, {
    timeParts
  })), [setState]);
  if (state.value !== value || state.use12HourClock !== use12HourClock) {
    setState({
      value,
      use12HourClock,
      timeParts: getValueParts(value, use12HourClock)
    });
  }
  return [state.timeParts, setTimeParts];
}
function TimeInput(uncontrolledProps) {
  const _useUncontrolled = useUncontrolled(uncontrolledProps, {
    value: "onChange"
  }), {
    value,
    use12HourClock,
    padValues: pad,
    emptyCharacter,
    precision,
    noClearButton,
    hoursAddon,
    minutesAddon,
    secondsAddon,
    millisecondsAddon,
    className,
    disabled,
    readOnly,
    datePart,
    onChange,
    onBlur,
    onFocus
  } = _useUncontrolled, props = _objectWithoutPropertiesLoose10(_useUncontrolled, _excluded10);
  let minsAddon = minutesAddon !== void 0 ? minutesAddon : precision === "seconds" || precision === "milliseconds" ? ":" : "";
  let secsAddon = secondsAddon !== void 0 ? secondsAddon : precision === "milliseconds" ? ":" : "";
  const ref = (0, import_react11.useRef)(null);
  const hourRef = (0, import_react11.useRef)(null);
  const [focusEvents, focused] = useFocusManager(ref, {
    disabled,
    onBlur,
    onFocus
  }, {
    didHandle: (focused2, e) => {
      var _hourRef$current;
      if (!focused2)
        return;
      if (!e.target.dataset.focusable)
        (_hourRef$current = hourRef.current) == null ? void 0 : _hourRef$current.focus();
      else
        select(e.target);
    }
  });
  const [timeParts, setTimeParts] = useTimePartState(value != null ? value : null, use12HourClock != null ? use12HourClock : false);
  function getDatePart() {
    return dates_default.startOf(datePart || /* @__PURE__ */ new Date(), "day");
  }
  const getMin = (part) => part === "hours" ? 1 : 0;
  const getMax = (part) => {
    if (part === "hours")
      return use12HourClock ? 12 : 23;
    if (part === "milliseconds")
      return 999;
    return 59;
  };
  function select(target = document.activeElement) {
    window.Promise.resolve().then(() => {
      if (focused)
        selectTextRange(target);
    });
  }
  const handleClear = () => {
    var _hourRef$current2;
    (_hourRef$current2 = hourRef.current) == null ? void 0 : _hourRef$current2.focus();
    if (value)
      onChange(null);
    else
      setTimeParts(getValueParts(null));
  };
  const handleChange = (part, event) => {
    const currentValue = timeParts[part];
    const {
      target
    } = event;
    const rawValue = target.value;
    let strValue = `${currentValue || ""}${rawValue}`;
    let numValue = +strValue;
    if (isNaN(numValue) || strValue && !isValid2(strValue, part, use12HourClock != null ? use12HourClock : false)) {
      if (isValid2(rawValue, part, use12HourClock != null ? use12HourClock : false) && !isNaN(+rawValue)) {
        strValue = rawValue;
        numValue = +rawValue;
      } else {
        return event.preventDefault();
      }
    }
    const nextValue = target.value ? numValue : null;
    notifyChange({
      [part]: nextValue
    });
    if (nextValue != null && isComplete(strValue, part, use12HourClock != null ? use12HourClock : false)) {
      focusNext(event.currentTarget, 1);
    } else {
      select(target);
    }
  };
  const handleSelect = ({
    target
  }) => {
    select(target);
  };
  const handleKeyDown = (part, event) => {
    const {
      key
    } = event;
    const input = event.currentTarget;
    const {
      selectionStart: start,
      selectionEnd: end
    } = input;
    const isRTL = getComputedStyle(input).getPropertyValue("direction") === "rtl";
    const isMeridiem = part === "meridiem";
    const isNext = key === (isRTL ? "ArrowLeft" : "ArrowRight");
    const isPrev = key === (isRTL ? "ArrowRight" : "ArrowLeft");
    if (key === "ArrowUp") {
      event.preventDefault();
      increment(part, 1);
    }
    if (key === "ArrowDown") {
      event.preventDefault();
      increment(part, -1);
    }
    if (isPrev && (isMeridiem || start - 1 < 0)) {
      event.preventDefault();
      focusNext(input, -1);
    }
    if (isNext && (isMeridiem || input.value.length <= end + 1)) {
      event.preventDefault();
      focusNext(input, 1);
    }
    if (readOnly && key !== "Tab") {
      event.preventDefault();
    }
    if (isMeridiem) {
      if (key === "a" || key === "A")
        notifyChange({
          meridiem: "AM"
        });
      if (key === "p" || key === "P")
        notifyChange({
          meridiem: "PM"
        });
    }
  };
  const increment = (part, inc) => {
    let nextPart = timeParts[part];
    if (part === "meridiem") {
      nextPart = nextPart === "AM" ? "PM" : "AM";
    } else {
      nextPart = (nextPart || 0) + inc;
      if (!isValid2(String(nextPart), part, use12HourClock != null ? use12HourClock : false))
        return;
    }
    notifyChange({
      [part]: nextPart
    });
    select();
  };
  function notifyChange(updates) {
    const nextTimeParts = Object.assign({}, timeParts, updates);
    if (value && isEmptyValue(nextTimeParts, precision)) {
      return onChange(null);
    }
    if (isPartialValue(nextTimeParts, precision))
      return setTimeParts(nextTimeParts);
    let {
      hours: hours2,
      minutes: minutes2,
      seconds: seconds2,
      milliseconds: milliseconds2,
      meridiem: meridiem2
    } = nextTimeParts;
    let nextDate = new Date(value || getDatePart());
    if (use12HourClock) {
      if (hours2 === 12)
        hours2 = 0;
      hours2 += meridiem2 === "PM" ? 12 : 0;
    }
    nextDate.setHours(hours2);
    nextDate.setMinutes(minutes2);
    if (seconds2 != null)
      nextDate.setSeconds(seconds2);
    if (milliseconds2 != null)
      nextDate.setMilliseconds(milliseconds2);
    onChange(nextDate, {
      lastValue: value,
      timeParts
    });
  }
  function focusNext(input, delta) {
    let nodes = qsa(ref.current, "* [data-focusable]");
    let next2 = nodes[nodes.indexOf(input) + delta];
    next2 == null ? void 0 : next2.focus();
    select(next2);
  }
  const {
    hours,
    minutes,
    seconds,
    milliseconds,
    meridiem
  } = timeParts;
  const showClear = !isEmptyValue(timeParts, precision);
  return import_react11.default.createElement(Widget_default, _extends11({}, props, {
    role: "group",
    ref
  }, focusEvents, {
    focused,
    disabled,
    readOnly,
    className: (0, import_classnames6.default)(className, "rw-time-input rw-widget-input")
  }), import_react11.default.createElement(DateTimePartInput_default, {
    size: 2,
    pad: pad ? 2 : void 0,
    value: hours,
    disabled,
    readOnly,
    "aria-label": "hours",
    min: getMin("hours"),
    max: getMax("hours"),
    ref: hourRef,
    emptyChar: emptyCharacter,
    onSelect: handleSelect,
    onChange: (e) => handleChange("hours", e),
    onKeyDown: (e) => handleKeyDown("hours", e)
  }), hoursAddon && import_react11.default.createElement("span", null, hoursAddon), import_react11.default.createElement(DateTimePartInput_default, {
    size: 2,
    pad: pad ? 2 : void 0,
    value: minutes,
    disabled,
    readOnly,
    "aria-label": "minutes",
    min: getMin("minutes"),
    max: getMax("minutes"),
    emptyChar: emptyCharacter,
    onSelect: handleSelect,
    onChange: (e) => handleChange("minutes", e),
    onKeyDown: (e) => handleKeyDown("minutes", e)
  }), minsAddon && import_react11.default.createElement("span", null, minsAddon), (precision === "seconds" || precision === "milliseconds") && import_react11.default.createElement(import_react11.default.Fragment, null, import_react11.default.createElement(DateTimePartInput_default, {
    size: 2,
    pad: pad ? 2 : void 0,
    value: seconds,
    disabled,
    readOnly,
    "aria-label": "seconds",
    min: getMin("seconds"),
    max: getMax("seconds"),
    emptyChar: emptyCharacter,
    onSelect: handleSelect,
    onChange: (e) => handleChange("seconds", e),
    onKeyDown: (e) => handleKeyDown("seconds", e)
  }), secsAddon && import_react11.default.createElement("span", null, secsAddon)), precision === "milliseconds" && import_react11.default.createElement(import_react11.default.Fragment, null, import_react11.default.createElement(DateTimePartInput_default, {
    size: 3,
    pad: pad ? 3 : void 0,
    value: milliseconds,
    disabled,
    readOnly,
    "aria-label": "milliseconds",
    min: getMin("milliseconds"),
    max: getMax("milliseconds"),
    emptyChar: emptyCharacter,
    onSelect: handleSelect,
    onChange: (e) => handleChange("milliseconds", e),
    onKeyDown: (e) => handleKeyDown("milliseconds", e)
  }), millisecondsAddon && import_react11.default.createElement("span", null, millisecondsAddon)), use12HourClock && import_react11.default.createElement("div", {
    role: "listbox",
    "aria-label": "AM/PM",
    "aria-disabled": disabled,
    "aria-readonly": readOnly,
    className: "rw-time-part-meridiem"
  }, import_react11.default.createElement("div", {
    "data-focusable": true,
    role: "option",
    "aria-atomic": true,
    "aria-selected": true,
    "aria-setsize": 2,
    "aria-live": "assertive",
    "aria-disabled": disabled,
    "aria-readonly": readOnly,
    "aria-posinset": meridiem === "AM" ? 1 : 2,
    tabIndex: !disabled ? 0 : void 0,
    onFocus: handleSelect,
    onSelect: handleSelect,
    onKeyDown: (e) => handleKeyDown("meridiem", e)
  }, import_react11.default.createElement("abbr", null, meridiem))), !noClearButton && import_react11.default.createElement(Button_default, {
    label: "clear input",
    onClick: handleClear,
    disabled: disabled || readOnly,
    className: (0, import_classnames6.default)("rw-time-input-clear", showClear && "rw-show")
  }, times));
}
TimeInput.propTypes = propTypes2;
TimeInput.defaultProps = defaultProps;
var TimeInput_default = TimeInput;

// node_modules/react-widgets/esm/useTabTrap.js
var import_react12 = __toESM(require_react());
var defaultSelector = ["input", "textarea", "select", 'button:not([tabindex="-1"])', '[tabindex="0"]'].join(",");
var getDocument = () => document;
function useTabTrap(ref, selector = defaultSelector) {
  const startedRef = (0, import_react12.useRef)(false);
  useEventListener(getDocument, "keydown", (event) => {
    if (!startedRef.current || !ref.current || event.key !== "Tab") {
      return;
    }
    const tabbables = ref.current.querySelectorAll(selector);
    if (event.shiftKey && event.target === tabbables[0]) {
      tabbables[tabbables.length - 1].focus();
      event.preventDefault();
    } else if (!event.shiftKey && event.target === tabbables[tabbables.length - 1] || !ref.current.contains(event.target)) {
      tabbables[0].focus();
      event.preventDefault();
    }
  });
  return (0, import_react12.useMemo)(() => ({
    focus() {
      const tabbables = ref.current.querySelectorAll(selector);
      const first = tabbables[0];
      if (first)
        first.focus();
    },
    start() {
      startedRef.current = true;
    },
    stop() {
      startedRef.current = false;
    }
  }), [ref, selector]);
}

// node_modules/react-widgets/esm/DatePicker.js
var _excluded11 = ["id", "value", "onChange", "onSelect", "onToggle", "onKeyDown", "onKeyPress", "onCurrentDateChange", "inputProps", "calendarProps", "timeInputProps", "popupProps", "autoFocus", "tabIndex", "disabled", "readOnly", "className", "valueFormat", "valueDisplayFormat", "valueEditFormat", "containerClassName", "name", "selectIcon", "placeholder", "includeTime", "min", "max", "open", "dropUp", "parse", "messages", "formats", "currentDate", "popupTransition", "popupComponent", "timePrecision", "aria-labelledby", "aria-describedby"];
function _extends12() {
  _extends12 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends12.apply(this, arguments);
}
function _objectWithoutPropertiesLoose11(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var propTypes3 = {
  /**
   * @example ['valuePicker', [ ['new Date()', null] ]]
   */
  value: import_prop_types4.default.instanceOf(Date),
  /**
   * @example ['onChangePicker', [ ['new Date()', null] ]]
   */
  onChange: import_prop_types4.default.func,
  /**
   * @example ['openDate']
   */
  open: import_prop_types4.default.bool,
  onToggle: import_prop_types4.default.func,
  /**
   * Default current date at which the calendar opens. If none is provided, opens at today's date or the `value` date (if any).
   */
  currentDate: import_prop_types4.default.instanceOf(Date),
  /**
   * Change event Handler that is called when the currentDate is changed. The handler is called with the currentDate object.
   */
  onCurrentDateChange: import_prop_types4.default.func,
  onSelect: import_prop_types4.default.func,
  /**
   * The minimum Date that can be selected. Min only limits selection, it doesn't constrain the date values that
   * can be typed or pasted into the widget. If you need this behavior you can constrain values via
   * the `onChange` handler.
   *
   * @example ['prop', ['min', 'new Date()']]
   */
  min: import_prop_types4.default.instanceOf(Date),
  /**
   * The maximum Date that can be selected. Max only limits selection, it doesn't constrain the date values that
   * can be typed or pasted into the widget. If you need this behavior you can constrain values via
   * the `onChange` handler.
   *
   * @example ['prop', ['max', 'new Date()']]
   */
  max: import_prop_types4.default.instanceOf(Date),
  /**
   * A formatting options used to display the date value. This is a shorthand for
   * setting both `valueDisplayFormat` and `valueEditFormat`.
   */
  valueFormat: import_prop_types4.default.any,
  /**
   * A formatting options used to display the date value. For more information about formats
   * visit the [Localization page](./localization)
   *
   * ```tsx live
   * import { DatePicker } from 'react-widgets';
   *
   * <DatePicker
   *   defaultValue={new Date()}
   *   valueDisplayFormat={{ dateStyle: "medium" }}
   * />
   * ```
   */
  valueDisplayFormat: import_prop_types4.default.any,
  /**
   * A formatting options used while the date input has focus. Useful for showing a simpler format for inputing.
   * For more information about formats visit the [Localization page](./localization)
   *
   * ```tsx live
   * import { DatePicker } from 'react-widgets';
   *
   * <DatePicker
   *   defaultValue={new Date()}
   *   valueEditFormat={{ dateStyle: "short" }}
   *   valueDisplayFormat={{ dateStyle: "medium" }}
   * />
   * ```
   */
  valueEditFormat: import_prop_types4.default.any,
  /**
   * Enable the time list component of the picker.
   */
  includeTime: import_prop_types4.default.bool,
  timePrecision: import_prop_types4.default.oneOf(["minutes", "seconds", "milliseconds"]),
  timeInputProps: import_prop_types4.default.object,
  /** Specify the element used to render the calendar dropdown icon. */
  selectIcon: import_prop_types4.default.node,
  dropUp: import_prop_types4.default.bool,
  popupTransition: import_prop_types4.default.elementType,
  placeholder: import_prop_types4.default.string,
  name: import_prop_types4.default.string,
  autoFocus: import_prop_types4.default.bool,
  /**
   * @example ['disabled', ['new Date()']]
   */
  disabled: import_prop_types4.default.bool,
  /**
   * @example ['readOnly', ['new Date()']]
   */
  readOnly: import_prop_types4.default.bool,
  /**
   * Determines how the widget parses the typed date string into a Date object. You can provide an array of formats to try,
   * or provide a function that returns a date to handle parsing yourself. When `parse` is unspecified and
   * the `format` prop is a `string` parse will automatically use that format as its default.
   */
  parse: import_prop_types4.default.oneOfType([import_prop_types4.default.any, import_prop_types4.default.func]),
  /** @ignore */
  tabIndex: import_prop_types4.default.any,
  /** @ignore */
  "aria-labelledby": import_prop_types4.default.string,
  /** @ignore */
  "aria-describedby": import_prop_types4.default.string,
  /** @ignore */
  localizer: import_prop_types4.default.any,
  onKeyDown: import_prop_types4.default.func,
  onKeyPress: import_prop_types4.default.func,
  onBlur: import_prop_types4.default.func,
  onFocus: import_prop_types4.default.func,
  /** Adds a css class to the input container element. */
  containerClassName: import_prop_types4.default.string,
  calendarProps: import_prop_types4.default.object,
  inputProps: import_prop_types4.default.object,
  messages: import_prop_types4.default.shape({
    dateButton: import_prop_types4.default.string
  })
};
var defaultProps2 = Object.assign({}, Calendar_default.defaultProps, {
  min: new Date(1900, 0, 1),
  max: new Date(2099, 11, 31),
  selectIcon: calendar,
  formats: {}
});
var DatePicker = import_react13.default.forwardRef((uncontrolledProps, outerRef) => {
  const _useUncontrolled = useUncontrolled(uncontrolledProps, {
    open: "onToggle",
    value: "onChange",
    currentDate: "onCurrentDateChange"
  }), {
    id,
    value,
    onChange,
    onSelect,
    onToggle,
    onKeyDown,
    onKeyPress,
    onCurrentDateChange,
    inputProps,
    calendarProps,
    timeInputProps,
    popupProps,
    autoFocus,
    tabIndex,
    disabled,
    readOnly,
    className,
    // @ts-ignore
    valueFormat,
    valueDisplayFormat = valueFormat,
    valueEditFormat = valueFormat,
    containerClassName,
    name,
    selectIcon,
    placeholder,
    includeTime = false,
    min,
    max,
    open,
    dropUp,
    parse,
    messages,
    formats,
    currentDate,
    popupTransition,
    popupComponent: Popup = Popup_default,
    timePrecision,
    "aria-labelledby": ariaLabelledby,
    "aria-describedby": ariaDescribedby
  } = _useUncontrolled, elementProps = _objectWithoutPropertiesLoose11(_useUncontrolled, _excluded11);
  const localizer = useLocalizer(messages, formats);
  const ref = (0, import_react13.useRef)(null);
  const calRef = (0, import_react13.useRef)(null);
  const tabTrap = useTabTrap(calRef);
  const inputId = useInstanceId(id, "_input");
  const dateId = useInstanceId(id, "_date");
  const currentFormat = includeTime ? "datetime" : "date";
  const toggle = useDropdownToggle(open, onToggle);
  const [focusEvents, focused] = useFocusManager(ref, uncontrolledProps, {
    didHandle(focused2) {
      if (!focused2) {
        toggle.close();
        tabTrap.stop();
      } else if (open) {
        tabTrap.focus();
      }
    }
  });
  const dateParser = (0, import_react13.useCallback)((str) => {
    var _localizer$parseDate, _ref;
    if (typeof parse == "function") {
      var _parse;
      return (_parse = parse(str, localizer)) != null ? _parse : null;
    }
    return (_localizer$parseDate = localizer.parseDate(str, (_ref = parse != null ? parse : valueEditFormat) != null ? _ref : valueDisplayFormat)) != null ? _localizer$parseDate : null;
  }, [localizer, parse, valueDisplayFormat, valueEditFormat]);
  const handleChange = useEventCallback((date, str, constrain) => {
    if (readOnly || disabled)
      return;
    if (constrain)
      date = inRangeValue2(date);
    if (onChange) {
      if (date == null || value == null) {
        if (date != value)
          onChange(date, str);
      } else if (!dates_default.eq(date, value)) {
        onChange(date, str);
      }
    }
  });
  const handleKeyDown = useEventCallback((e) => {
    if (readOnly)
      return;
    notify(onKeyDown, [e]);
    if (e.defaultPrevented)
      return;
    if (e.key === "Escape" && open) {
      toggle.close();
    } else if (e.altKey) {
      if (e.key === "ArrowDown") {
        e.preventDefault();
        toggle.open();
      } else if (e.key === "ArrowUp") {
        e.preventDefault();
        toggle.close();
      }
    }
  });
  const handleKeyPress = useEventCallback((e) => {
    notify(onKeyPress, [e]);
    if (e.defaultPrevented)
      return;
  });
  const handleDateSelect = useEventCallback((date) => {
    var _ref$current;
    let dateTime = dates_default.merge(date, value, currentDate);
    let dateStr = formatDate(date);
    if (!includeTime)
      toggle.close();
    notify(onSelect, [dateTime, dateStr]);
    handleChange(dateTime, dateStr, true);
    (_ref$current = ref.current) == null ? void 0 : _ref$current.focus();
  });
  const handleTimeChange = useEventCallback((date) => {
    handleChange(date, formatDate(date), true);
  });
  const handleCalendarClick = useEventCallback((e) => {
    if (readOnly || disabled)
      return;
    e.preventDefault();
    toggle();
  });
  const handleOpening = () => {
    tabTrap.start();
    requestAnimationFrame(() => {
      tabTrap.focus();
    });
  };
  const handleClosing = () => {
    tabTrap.stop();
    if (focused)
      focus();
  };
  function focus() {
    var _calRef$current, _ref$current2;
    if (open)
      (_calRef$current = calRef.current) == null ? void 0 : _calRef$current.focus();
    else
      (_ref$current2 = ref.current) == null ? void 0 : _ref$current2.focus();
  }
  function inRangeValue2(value2) {
    if (value2 == null)
      return value2;
    return dates_default.max(dates_default.min(value2, max), min);
  }
  function formatDate(date) {
    return date instanceof Date && !isNaN(date.getTime()) ? localizer.formatDate(date, currentFormat) : "";
  }
  (0, import_react13.useImperativeHandle)(outerRef, () => ({
    focus
  }));
  let shouldRenderList = useFirstFocusedRender(focused, open);
  const inputReadOnly = (inputProps == null ? void 0 : inputProps.readOnly) != null ? inputProps == null ? void 0 : inputProps.readOnly : readOnly;
  return import_react13.default.createElement(Widget_default, _extends12({}, elementProps, {
    defaultValue: void 0,
    open: !!open,
    dropUp,
    focused,
    disabled,
    readOnly,
    onKeyDown: handleKeyDown,
    onKeyPress: handleKeyPress
  }, focusEvents, {
    className: (0, import_classnames7.default)(className, "rw-date-picker")
  }), import_react13.default.createElement(WidgetPicker_default, {
    className: containerClassName
  }, import_react13.default.createElement(DatePickerInput_default, _extends12({}, inputProps, {
    id: inputId,
    ref,
    role: "combobox",
    name,
    value,
    tabIndex,
    autoFocus,
    placeholder,
    disabled,
    readOnly: inputReadOnly,
    formatter: currentFormat,
    displayFormat: valueDisplayFormat,
    editFormat: valueEditFormat,
    editing: focused,
    localizer,
    parse: dateParser,
    onChange: handleChange,
    "aria-haspopup": true,
    "aria-labelledby": ariaLabelledby,
    "aria-describedby": ariaDescribedby,
    "aria-expanded": !!open,
    "aria-owns": dateId
  })), import_react13.default.createElement(InputAddon_default, {
    icon: selectIcon,
    label: localizer.messages.dateButton(),
    disabled: disabled || readOnly,
    onClick: handleCalendarClick
  })), !!shouldRenderList && import_react13.default.createElement(Popup, _extends12({}, popupProps, {
    dropUp,
    open,
    role: "dialog",
    ref: calRef,
    id: dateId,
    className: "rw-calendar-popup",
    transition: popupTransition,
    onEntering: handleOpening,
    onExited: handleClosing
  }), import_react13.default.createElement(Calendar_default, _extends12({
    min,
    max,
    bordered: false
  }, calendarProps, {
    messages: Object.assign({}, messages, calendarProps == null ? void 0 : calendarProps.messages),
    tabIndex: -1,
    value,
    autoFocus: false,
    onChange: handleDateSelect,
    currentDate,
    onCurrentDateChange,
    "aria-hidden": !open,
    "aria-live": "polite",
    "aria-labelledby": inputId
  })), includeTime && import_react13.default.createElement(TimeInput_default, _extends12({}, timeInputProps, {
    value,
    precision: timePrecision,
    onChange: handleTimeChange,
    datePart: currentDate
  }))));
});
DatePicker.displayName = "DatePicker";
DatePicker.propTypes = propTypes3;
DatePicker.defaultProps = defaultProps2;
var DatePicker_default = DatePicker;
export {
  DatePicker_default as default
};
//# sourceMappingURL=react-widgets_DatePicker.js.map
