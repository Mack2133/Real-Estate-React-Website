import {
  FocusListContext,
  ListOption_default,
  List_default,
  presets,
  useAccessors,
  useActiveDescendant,
  useFilteredData,
  useFocusList,
  useWillUnmount
} from "./chunk-TOMEQ7SX.js";
import {
  useAutoFocus
} from "./chunk-XTTWT534.js";
import {
  Popup_default,
  useDropdownToggle
} from "./chunk-UHMEWT6U.js";
import {
  accessor,
  disabled,
  elementType,
  message
} from "./chunk-3T2BHOZF.js";
import {
  useLocalizer
} from "./chunk-C5XAPTI4.js";
import {
  Spinner,
  WidgetPicker_default,
  Widget_default,
  caretDown,
  notify,
  require_classnames,
  useFirstFocusedRender,
  useFocusManager,
  useInstanceId,
  useMounted,
  useUncontrolledProp
} from "./chunk-JMLJIJD3.js";
import {
  require_prop_types
} from "./chunk-4LVSZ64H.js";
import "./chunk-XBHG3ID7.js";
import {
  require_react
} from "./chunk-YSDLPTTY.js";
import {
  __toESM
} from "./chunk-ZS7NZCD4.js";

// node_modules/react-widgets/esm/DropdownList.js
var import_classnames3 = __toESM(require_classnames());
var import_prop_types = __toESM(require_prop_types());
var import_react4 = __toESM(require_react());

// node_modules/@restart/hooks/esm/useTimeout.js
var import_react = __toESM(require_react());
var MAX_DELAY_MS = 2 ** 31 - 1;
function setChainedTimeout(handleRef, fn, timeoutAtMs) {
  const delayMs = timeoutAtMs - Date.now();
  handleRef.current = delayMs <= MAX_DELAY_MS ? setTimeout(fn, delayMs) : setTimeout(() => setChainedTimeout(handleRef, fn, timeoutAtMs), MAX_DELAY_MS);
}
function useTimeout() {
  const isMounted = useMounted();
  const handleRef = (0, import_react.useRef)();
  useWillUnmount(() => clearTimeout(handleRef.current));
  return (0, import_react.useMemo)(() => {
    const clear = () => clearTimeout(handleRef.current);
    function set(fn, delayMs = 0) {
      if (!isMounted())
        return;
      clear();
      if (delayMs <= MAX_DELAY_MS) {
        handleRef.current = setTimeout(fn, delayMs);
      } else {
        setChainedTimeout(handleRef, fn, Date.now() + delayMs);
      }
    }
    return {
      set,
      clear,
      handleRef
    };
  }, []);
}

// node_modules/react-widgets/esm/AddToListOption.js
var PropTypes = __toESM(require_prop_types());
var import_react2 = __toESM(require_react());
var _excluded = ["children"];
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var CREATE_OPTION = {};
var propTypes = {
  searchTerm: PropTypes.string,
  focused: PropTypes.bool,
  onSelect: PropTypes.func.isRequired,
  activeId: PropTypes.string
};
function AddToListOption(_ref) {
  let {
    children
  } = _ref, props = _objectWithoutPropertiesLoose(_ref, _excluded);
  return import_react2.default.createElement(ListOption_default, _extends({}, props, {
    dataItem: CREATE_OPTION,
    className: "rw-list-option-create",
    selected: false
  }), children);
}
AddToListOption.propTypes = propTypes;
var AddToListOption_default = AddToListOption;

// node_modules/react-widgets/esm/DropdownListInput.js
var import_classnames = __toESM(require_classnames());
var import_react3 = __toESM(require_react());
var DropdownListInput = import_react3.default.forwardRef(function({
  name,
  autoComplete,
  value,
  allowSearch,
  placeholder,
  textAccessor,
  dataKeyAccessor,
  searchTerm,
  onSearch,
  onAutofill,
  onAutofillChange,
  renderValue,
  disabled: disabled2,
  readOnly
}, ref) {
  const [autofilling, setAutofilling] = (0, import_react3.useState)(false);
  const searchRef = (0, import_react3.useRef)(null);
  const handleAutofillDetect = ({
    animationName
  }) => {
    let autofilling2;
    if (animationName === "react-widgets-autofill-start")
      autofilling2 = true;
    else if (animationName === "react-widgets-autofill-cancel")
      autofilling2 = false;
    else
      return;
    setAutofilling(autofilling2);
    onAutofill(autofilling2);
  };
  const handleAutofill = (e) => {
    setAutofilling(false);
    onAutofillChange(e);
  };
  let dataKey = dataKeyAccessor(value);
  let text = value == null ? "" : textAccessor(value);
  let strValue = String(dataKey != null ? dataKey : "");
  if (strValue === String({}))
    strValue = "";
  const inputValue = !value && placeholder ? import_react3.default.createElement("span", {
    className: "rw-placeholder"
  }, placeholder) : renderValue ? renderValue({
    item: value,
    dataKey,
    text
  }) : text;
  (0, import_react3.useImperativeHandle)(ref, () => ({
    focus() {
      if (searchRef.current)
        searchRef.current.focus();
    }
  }));
  const style = autofilling ? {
    display: "none"
  } : void 0;
  return import_react3.default.createElement("div", {
    className: "rw-dropdown-list-input"
  }, autoComplete !== "off" && import_react3.default.createElement("input", {
    name,
    tabIndex: -1,
    disabled: disabled2,
    readOnly,
    value: strValue == null ? "" : strValue,
    autoComplete,
    onChange: handleAutofill,
    onAnimationStart: handleAutofillDetect,
    "aria-hidden": !autofilling,
    className: (0, import_classnames.default)("rw-detect-autofill", !autofilling && "rw-sr")
  }), import_react3.default.createElement(import_react3.default.Fragment, null, allowSearch && import_react3.default.createElement("input", {
    ref: searchRef,
    disabled: disabled2,
    readOnly,
    style,
    className: "rw-dropdownlist-search",
    autoComplete: "off",
    value: searchTerm || "",
    size: (searchTerm || "").length + 2,
    onChange: onSearch
  }), !searchTerm && import_react3.default.createElement("span", {
    className: "rw-dropdown-list-value",
    style
  }, inputValue)));
});
DropdownListInput.displayName = "DropdownListInput";
var DropdownListInput_default = DropdownListInput;

// node_modules/react-widgets/esm/canShowCreate.js
function canShowCreate(allowCreate, {
  searchTerm = "",
  data,
  dataItems,
  accessors
}) {
  const eq = (v) => accessors.text(v).toLowerCase() === searchTerm.toLowerCase();
  const hasExtactMatch = () => dataItems && dataItems.some(eq) || data.some(eq);
  return !!((allowCreate === true || allowCreate === "onFilter" && searchTerm) && !hasExtactMatch());
}

// node_modules/react-widgets/esm/PickerCaret.js
var import_classnames2 = __toESM(require_classnames());
var React3 = __toESM(require_react());
var _excluded2 = ["className", "busy", "visible", "icon", "spinner"];
function _extends2() {
  _extends2 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var DropdownCaret = (_ref) => {
  let {
    className,
    busy,
    visible,
    icon = caretDown,
    spinner = Spinner
  } = _ref, props = _objectWithoutPropertiesLoose2(_ref, _excluded2);
  return React3.createElement("span", _extends2({}, props, {
    "aria-hidden": "true",
    className: (0, import_classnames2.default)(className, "rw-btn rw-picker-caret")
  }), busy ? spinner : visible ? icon : null);
};
var PickerCaret_default = DropdownCaret;

// node_modules/react-widgets/esm/DropdownList.js
var _excluded3 = ["id", "autoFocus", "textField", "dataKey", "value", "defaultValue", "onChange", "open", "defaultOpen", "onToggle", "searchTerm", "defaultSearchTerm", "onSearch", "filter", "allowCreate", "delay", "focusFirstItem", "className", "containerClassName", "placeholder", "busy", "disabled", "readOnly", "selectIcon", "busySpinner", "dropUp", "tabIndex", "popupTransition", "name", "autoComplete", "onSelect", "onCreate", "onKeyPress", "onKeyDown", "onClick", "inputProps", "listProps", "popupProps", "renderListItem", "renderListGroup", "optionComponent", "renderValue", "groupBy", "onBlur", "onFocus", "listComponent", "popupComponent", "data", "messages"];
function _extends3() {
  _extends3 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends3.apply(this, arguments);
}
function _objectWithoutPropertiesLoose3(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var propTypes2 = {
  value: import_prop_types.default.any,
  /**
   * @type {function (
   *  dataItems: ?any,
   *  metadata: {
   *    lastValue: ?any,
   *    searchTerm: ?string
   *    originalEvent: SyntheticEvent,
   *  }
   * ): void}
   */
  onChange: import_prop_types.default.func,
  open: import_prop_types.default.bool,
  onToggle: import_prop_types.default.func,
  data: import_prop_types.default.array,
  dataKey: accessor,
  textField: accessor,
  allowCreate: import_prop_types.default.oneOf([true, false, "onFilter"]),
  /**
   * A React render prop for customizing the rendering of the DropdownList
   * value
   */
  renderValue: import_prop_types.default.func,
  renderListItem: import_prop_types.default.func,
  listComponent: elementType,
  optionComponent: elementType,
  renderPopup: import_prop_types.default.func,
  renderListGroup: import_prop_types.default.func,
  groupBy: accessor,
  /**
   *
   * @type {(dataItem: ?any, metadata: { originalEvent: SyntheticEvent }) => void}
   */
  onSelect: import_prop_types.default.func,
  onCreate: import_prop_types.default.func,
  /**
   * @type function(searchTerm: string, metadata: { action, lastSearchTerm, originalEvent? })
   */
  onSearch: import_prop_types.default.func,
  searchTerm: import_prop_types.default.string,
  busy: import_prop_types.default.bool,
  /** Specify the element used to render the select (down arrow) icon. */
  selectIcon: import_prop_types.default.node,
  /** Specify the element used to render the busy indicator */
  busySpinner: import_prop_types.default.node,
  placeholder: import_prop_types.default.string,
  dropUp: import_prop_types.default.bool,
  popupTransition: elementType,
  disabled: disabled.acceptsArray,
  readOnly: disabled,
  /** Adds a css class to the input container element. */
  containerClassName: import_prop_types.default.string,
  inputProps: import_prop_types.default.object,
  listProps: import_prop_types.default.object,
  messages: import_prop_types.default.shape({
    open: import_prop_types.default.string,
    emptyList: message,
    emptyFilter: message,
    createOption: message
  })
};
function useSearchWordBuilder(delay) {
  const timeout = useTimeout();
  const wordRef = (0, import_react4.useRef)("");
  function search(character, cb) {
    let word = (wordRef.current + character).toLowerCase();
    if (!character)
      return;
    wordRef.current = word;
    timeout.set(() => {
      wordRef.current = "";
      cb(word);
    }, delay);
  }
  return search;
}
var DropdownListImpl = import_react4.default.forwardRef(function DropdownList(_ref, outerRef) {
  let {
    id,
    autoFocus,
    textField,
    dataKey,
    value,
    defaultValue,
    onChange,
    open,
    defaultOpen = false,
    onToggle,
    searchTerm,
    defaultSearchTerm = "",
    onSearch,
    filter = true,
    allowCreate = false,
    delay = 500,
    focusFirstItem,
    className,
    containerClassName,
    placeholder,
    busy,
    disabled: disabled2,
    readOnly,
    selectIcon = caretDown,
    busySpinner,
    dropUp,
    tabIndex,
    popupTransition,
    name,
    autoComplete,
    onSelect,
    onCreate,
    onKeyPress,
    onKeyDown,
    onClick,
    inputProps,
    listProps,
    popupProps,
    renderListItem,
    renderListGroup,
    optionComponent,
    renderValue,
    groupBy,
    onBlur,
    onFocus,
    listComponent: ListComponent = List_default,
    popupComponent: Popup = Popup_default,
    data: rawData = [],
    messages: userMessages
  } = _ref, elementProps = _objectWithoutPropertiesLoose3(_ref, _excluded3);
  const [currentValue, handleChange] = useUncontrolledProp(value, defaultValue, onChange);
  const [currentOpen, handleOpen] = useUncontrolledProp(open, defaultOpen, onToggle);
  const [currentSearch, handleSearch] = useUncontrolledProp(searchTerm, defaultSearchTerm, onSearch);
  const ref = (0, import_react4.useRef)(null);
  const filterRef = (0, import_react4.useRef)(null);
  const listRef = (0, import_react4.useRef)(null);
  const inputId = useInstanceId(id, "_input");
  const listId = useInstanceId(id, "_listbox");
  const activeId = useInstanceId(id, "_listbox_active_option");
  const accessors = useAccessors(textField, dataKey);
  const localizer = useLocalizer(userMessages);
  useAutoFocus(!!autoFocus, ref);
  const toggle = useDropdownToggle(currentOpen, handleOpen);
  const isDisabled = disabled2 === true;
  const isReadOnly = !!readOnly;
  const [focusEvents, focused] = useFocusManager(ref, {
    disabled: isDisabled,
    onBlur,
    onFocus
  }, {
    didHandle(focused2) {
      if (focused2) {
        if (filter)
          focus();
        return;
      }
      toggle.close();
      clearSearch();
    }
  });
  const data = useFilteredData(rawData, currentOpen ? filter : false, currentSearch, accessors.text);
  const selectedItem = (0, import_react4.useMemo)(() => data[accessors.indexOf(data, currentValue)], [data, currentValue, accessors]);
  const list = useFocusList({
    activeId,
    scope: ref,
    focusFirstItem,
    anchorItem: currentOpen ? selectedItem : void 0
  });
  const [autofilling, setAutofilling] = (0, import_react4.useState)(false);
  const nextSearchChar = useSearchWordBuilder(delay);
  const focusedItem = list.getFocused();
  useActiveDescendant(ref, activeId, focusedItem && currentOpen, [focusedItem]);
  const showCreateOption = canShowCreate(allowCreate, {
    searchTerm: currentSearch,
    data,
    accessors
  });
  const handleCreate = (event) => {
    notify(onCreate, [currentSearch]);
    clearSearch(event);
    toggle.close();
    focus();
  };
  const handleSelect = (dataItem, originalEvent) => {
    if (readOnly || isDisabled)
      return;
    if (dataItem === void 0)
      return;
    originalEvent == null ? void 0 : originalEvent.preventDefault();
    if (dataItem === CREATE_OPTION) {
      handleCreate(originalEvent);
      return;
    }
    notify(onSelect, [dataItem, {
      originalEvent
    }]);
    change(dataItem, originalEvent, true);
    toggle.close();
    focus();
  };
  const handleClick = (e) => {
    if (readOnly || isDisabled)
      return;
    e.preventDefault();
    focus();
    toggle();
    notify(onClick, [e]);
  };
  const handleKeyDown = (e) => {
    if (readOnly || isDisabled)
      return;
    let {
      key,
      altKey,
      ctrlKey,
      shiftKey
    } = e;
    notify(onKeyDown, [e]);
    let closeWithFocus = () => {
      clearSearch();
      toggle.close();
      if (currentOpen)
        setTimeout(focus);
    };
    if (e.defaultPrevented)
      return;
    if (key === "End" && currentOpen && !shiftKey) {
      e.preventDefault();
      list.focus(list.last());
    } else if (key === "Home" && currentOpen && !shiftKey) {
      e.preventDefault();
      list.focus(list.first());
    } else if (key === "Escape" && (currentOpen || currentSearch)) {
      e.preventDefault();
      closeWithFocus();
    } else if (key === "Enter" && currentOpen && ctrlKey && showCreateOption) {
      e.preventDefault();
      handleCreate(e);
    } else if ((key === "Enter" || key === " " && !filter) && currentOpen) {
      e.preventDefault();
      if (list.hasFocused())
        handleSelect(list.getFocused(), e);
    } else if (key === "ArrowDown") {
      e.preventDefault();
      if (!currentOpen) {
        toggle.open();
        return;
      }
      list.focus(list.next());
    } else if (key === "ArrowUp") {
      e.preventDefault();
      if (altKey)
        return closeWithFocus();
      list.focus(list.prev());
    }
  };
  const handleKeyPress = (e) => {
    if (readOnly || isDisabled)
      return;
    notify(onKeyPress, [e]);
    if (e.defaultPrevented || filter)
      return;
    nextSearchChar(String.fromCharCode(e.which), (word) => {
      if (!currentOpen)
        return;
      let isValid = (item) => presets.startsWith(accessors.text(item).toLowerCase(), word.toLowerCase());
      const [items, focusedItem2] = list.get();
      const len = items.length;
      const startIdx = items.indexOf(focusedItem2) + 1;
      const offset = startIdx >= len ? 0 : startIdx;
      let idx = 0;
      let pointer = offset;
      while (idx < len) {
        pointer = (idx + offset) % len;
        let item = items[pointer];
        if (isValid(list.toDataItem(item)))
          break;
        idx++;
      }
      if (idx === len)
        return;
      list.focus(items[pointer]);
    });
  };
  const handleInputChange = (e) => {
    if (!currentOpen && !e.target.value.trim()) {
      e.preventDefault();
    } else {
      search(e.target.value, e, "input");
    }
    toggle.open();
  };
  const handleAutofillChange = (e) => {
    let filledValue = e.target.value.toLowerCase();
    if (filledValue === "")
      return void change(null);
    for (const item of rawData) {
      if (String(accessors.value(item)).toLowerCase() === filledValue || accessors.text(item).toLowerCase() === filledValue) {
        change(item, e);
        break;
      }
    }
  };
  function change(nextValue, originalEvent, selected = false) {
    if (!accessors.matches(nextValue, currentValue)) {
      notify(handleChange, [nextValue, {
        originalEvent,
        source: selected ? "listbox" : "input",
        lastValue: currentValue,
        searchTerm: currentSearch
      }]);
      clearSearch(originalEvent);
      toggle.close();
    }
  }
  function focus() {
    if (filter)
      filterRef.current.focus();
    else
      ref.current.focus();
  }
  function clearSearch(originalEvent) {
    search("", originalEvent, "clear");
  }
  function search(nextSearchTerm, originalEvent, action = "input") {
    if (currentSearch !== nextSearchTerm)
      handleSearch(nextSearchTerm, {
        action,
        originalEvent,
        lastSearchTerm: currentSearch
      });
  }
  (0, import_react4.useImperativeHandle)(outerRef, () => ({
    focus
  }));
  let valueItem = accessors.findOrSelf(data, currentValue);
  let shouldRenderPopup = useFirstFocusedRender(focused, currentOpen);
  const widgetProps = Object.assign({}, elementProps, {
    role: "combobox",
    id: inputId,
    //tab index when there is no filter input to take focus
    tabIndex: filter ? -1 : tabIndex || 0,
    // FIXME: only when item exists
    "aria-owns": elementProps["aria-owns"] ? `${listId} ${elementProps["aria-owns"]}` : listId,
    "aria-controls": elementProps["aria-controls"] ? `${listId} ${elementProps["aria-controls"]}` : listId,
    "aria-expanded": !!currentOpen,
    "aria-haspopup": "listbox",
    "aria-busy": !!busy,
    "aria-live": currentOpen ? "polite" : void 0,
    "aria-autocomplete": "list",
    "aria-disabled": isDisabled,
    "aria-readonly": isReadOnly
  });
  return import_react4.default.createElement(FocusListContext.Provider, {
    value: list.context
  }, import_react4.default.createElement(Widget_default, _extends3({}, widgetProps, {
    open: !!currentOpen,
    dropUp: !!dropUp,
    focused: !!focused,
    disabled: isDisabled,
    readOnly: isReadOnly,
    autofilling
  }, focusEvents, {
    onKeyDown: handleKeyDown,
    onKeyPress: handleKeyPress,
    className: (0, import_classnames3.default)(className, "rw-dropdown-list"),
    ref
  }), import_react4.default.createElement(WidgetPicker_default, {
    onClick: handleClick,
    tabIndex: filter ? -1 : 0,
    className: (0, import_classnames3.default)(containerClassName, "rw-widget-input")
  }, import_react4.default.createElement(DropdownListInput_default, _extends3({}, inputProps, {
    value: valueItem,
    dataKeyAccessor: accessors.value,
    textAccessor: accessors.text,
    name,
    readOnly,
    disabled: isDisabled,
    allowSearch: !!filter,
    searchTerm: currentSearch,
    ref: filterRef,
    autoComplete,
    onSearch: handleInputChange,
    onAutofill: setAutofilling,
    onAutofillChange: handleAutofillChange,
    placeholder,
    renderValue
  })), import_react4.default.createElement(PickerCaret_default, {
    visible: true,
    busy,
    icon: selectIcon,
    spinner: busySpinner
  })), shouldRenderPopup && import_react4.default.createElement(Popup, _extends3({}, popupProps, {
    dropUp,
    open: currentOpen,
    transition: popupTransition,
    onEntered: focus,
    onEntering: () => listRef.current.scrollIntoView()
  }), import_react4.default.createElement(ListComponent, _extends3({}, listProps, {
    id: listId,
    data,
    tabIndex: -1,
    disabled: disabled2,
    groupBy,
    searchTerm: currentSearch,
    accessors,
    renderItem: renderListItem,
    renderGroup: renderListGroup,
    optionComponent,
    value: selectedItem,
    onChange: (d, meta) => handleSelect(d, meta.originalEvent),
    "aria-live": currentOpen ? "polite" : void 0,
    "aria-labelledby": inputId,
    "aria-hidden": !currentOpen,
    ref: listRef,
    messages: {
      emptyList: rawData.length ? localizer.messages.emptyFilter : localizer.messages.emptyList
    }
  })), showCreateOption && import_react4.default.createElement(AddToListOption_default, {
    onSelect: handleCreate
  }, localizer.messages.createOption(currentValue, currentSearch || "")))));
});
DropdownListImpl.displayName = "DropdownList";
DropdownListImpl.propTypes = propTypes2;
var DropdownList_default = DropdownListImpl;
export {
  DropdownList_default as default
};
//# sourceMappingURL=react-widgets_DropdownList.js.map
