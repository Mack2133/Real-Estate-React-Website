import {
  InputAddon_default
} from "./chunk-QLGIIAPK.js";
import {
  FocusListContext,
  List_default,
  useAccessors,
  useActiveDescendant,
  useFilteredData,
  useFocusList
} from "./chunk-TOMEQ7SX.js";
import {
  Popup_default,
  useDropdownToggle
} from "./chunk-UHMEWT6U.js";
import {
  Input_default
} from "./chunk-FXI54CGI.js";
import {
  accessor,
  disabled,
  message
} from "./chunk-3T2BHOZF.js";
import {
  Spinner,
  WidgetPicker_default,
  Widget_default,
  caretDown,
  notify,
  require_classnames,
  useFirstFocusedRender,
  useFocusManager,
  useInstanceId,
  useMessagesWithDefaults,
  useUncontrolledProp
} from "./chunk-JMLJIJD3.js";
import {
  require_prop_types
} from "./chunk-4LVSZ64H.js";
import "./chunk-XBHG3ID7.js";
import {
  require_react
} from "./chunk-YSDLPTTY.js";
import {
  __toESM
} from "./chunk-ZS7NZCD4.js";

// node_modules/react-widgets/esm/Combobox.js
var import_classnames = __toESM(require_classnames());
var PropTypes = __toESM(require_prop_types());
var React = __toESM(require_react());
var import_react = __toESM(require_react());
var _excluded = ["id", "className", "containerClassName", "placeholder", "autoFocus", "textField", "dataKey", "autoSelectMatches", "focusFirstItem", "value", "defaultValue", "onChange", "open", "defaultOpen", "onToggle", "filter", "busy", "disabled", "readOnly", "selectIcon", "hideCaret", "hideEmptyPopup", "busySpinner", "dropUp", "tabIndex", "popupTransition", "name", "onSelect", "onKeyDown", "onBlur", "onFocus", "inputProps", "listProps", "popupProps", "groupBy", "renderListItem", "renderListGroup", "optionComponent", "listComponent", "popupComponent", "data", "messages"];
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function indexOf(data, searchTerm, text) {
  if (!searchTerm.trim())
    return -1;
  for (let idx = 0; idx < data.length; idx++)
    if (text(data[idx]).toLowerCase() === searchTerm)
      return idx;
  return -1;
}
var propTypes = {
  value: PropTypes.any,
  onChange: PropTypes.func,
  open: PropTypes.bool,
  onToggle: PropTypes.func,
  renderListItem: PropTypes.func,
  listComponent: PropTypes.elementType,
  renderListGroup: PropTypes.func,
  groupBy: accessor,
  data: PropTypes.array,
  dataKey: accessor,
  textField: accessor,
  name: PropTypes.string,
  /** Do not show the auto complete list when it returns no results. */
  hideEmptyPopup: PropTypes.bool,
  /** Hide the combobox dropdown indicator. */
  hideCaret: PropTypes.bool,
  /**
   *
   * @type {(dataItem: ?any, metadata: { originalEvent: SyntheticEvent }) => void}
   */
  onSelect: PropTypes.func,
  autoFocus: PropTypes.bool,
  disabled: disabled.acceptsArray,
  readOnly: disabled,
  busy: PropTypes.bool,
  /** Specify the element used to render the select (down arrow) icon. */
  selectIcon: PropTypes.node,
  /** Specify the element used to render the busy indicator */
  busySpinner: PropTypes.node,
  dropUp: PropTypes.bool,
  popupTransition: PropTypes.elementType,
  placeholder: PropTypes.string,
  /** Adds a css class to the input container element. */
  containerClassName: PropTypes.string,
  inputProps: PropTypes.object,
  listProps: PropTypes.object,
  messages: PropTypes.shape({
    openCombobox: message,
    emptyList: message,
    emptyFilter: message
  })
};
var ComboboxImpl = React.forwardRef(function Combobox(_ref, outerRef) {
  let {
    id,
    className,
    containerClassName,
    placeholder,
    autoFocus,
    textField,
    dataKey,
    autoSelectMatches,
    focusFirstItem = false,
    value,
    defaultValue = "",
    onChange,
    open,
    defaultOpen = false,
    onToggle,
    filter = true,
    busy,
    disabled: disabled2,
    readOnly,
    selectIcon = caretDown,
    hideCaret,
    hideEmptyPopup,
    busySpinner,
    dropUp,
    tabIndex,
    popupTransition,
    name,
    onSelect,
    onKeyDown,
    onBlur,
    onFocus,
    inputProps,
    listProps,
    popupProps,
    groupBy,
    renderListItem,
    renderListGroup,
    optionComponent,
    listComponent: ListComponent = List_default,
    popupComponent: Popup = Popup_default,
    data: rawData = [],
    messages: userMessages
  } = _ref, elementProps = _objectWithoutPropertiesLoose(_ref, _excluded);
  let [currentValue, handleChange] = useUncontrolledProp(value, defaultValue, onChange);
  const [currentOpen, handleOpen] = useUncontrolledProp(open, defaultOpen, onToggle);
  const ref = (0, import_react.useRef)(null);
  const inputRef = (0, import_react.useRef)(null);
  const listRef = (0, import_react.useRef)(null);
  const [suggestion, setSuggestion] = (0, import_react.useState)(null);
  const shouldFilter = (0, import_react.useRef)(false);
  const inputId = useInstanceId(id, "_input");
  const listId = useInstanceId(id, "_listbox");
  const activeId = useInstanceId(id, "_listbox_active_option");
  const accessors = useAccessors(textField, dataKey);
  const messages = useMessagesWithDefaults(userMessages);
  const toggle = useDropdownToggle(currentOpen, handleOpen);
  const isDisabled = disabled2 === true;
  const isReadOnly = !!readOnly;
  const data = useFilteredData(rawData, filter, shouldFilter.current ? accessors.text(currentValue) : void 0, accessors.text);
  const selectedItem = (0, import_react.useMemo)(() => data[accessors.indexOf(data, currentValue)], [data, currentValue, accessors]);
  const list = useFocusList({
    activeId,
    scope: ref,
    focusFirstItem,
    anchorItem: currentOpen ? selectedItem : void 0
  });
  const [focusEvents, focused] = useFocusManager(ref, {
    disabled: isDisabled,
    onBlur,
    onFocus
  }, {
    didHandle(focused2) {
      if (!focused2) {
        shouldFilter.current = false;
        toggle.close();
        setSuggestion(null);
        list.focus(void 0);
      } else {
        focus({
          preventScroll: true
        });
      }
    }
  });
  useActiveDescendant(ref, activeId, currentOpen, [list.getFocused()]);
  const handleClick = (e) => {
    if (readOnly || isDisabled)
      return;
    e.preventDefault();
    focus();
    toggle();
  };
  const handleSelect = (data2, originalEvent) => {
    toggle.close();
    shouldFilter.current = false;
    setSuggestion(null);
    notify(onSelect, [data2, {
      originalEvent
    }]);
    change(data2, originalEvent, true);
    focus({
      preventScroll: true
    });
  };
  const handleInputKeyDown = ({
    key
  }) => {
    if (key === "Backspace" || key === "Delete") {
      list.focus(null);
    }
  };
  const handleInputChange = (event) => {
    let idx = autoSelectMatches ? indexOf(rawData, event.target.value.toLowerCase(), accessors.text) : -1;
    shouldFilter.current = true;
    setSuggestion(null);
    const nextValue = idx === -1 ? event.target.value : rawData[idx];
    change(nextValue, event);
    if (!nextValue)
      toggle.close();
    else
      toggle.open();
  };
  const handleKeyDown = (e) => {
    if (readOnly)
      return;
    let {
      key,
      altKey,
      shiftKey
    } = e;
    notify(onKeyDown, [e]);
    if (e.defaultPrevented)
      return;
    const select = (item) => item != null && handleSelect(item, e);
    const setFocused = (el) => {
      if (!el)
        return;
      setSuggestion(list.toDataItem(el));
      list.focus(el);
    };
    if (key === "End" && currentOpen && !shiftKey) {
      e.preventDefault();
      setFocused(list.last());
    } else if (key === "Home" && currentOpen && !shiftKey) {
      e.preventDefault();
      setFocused(list.first());
    } else if (key === "Escape" && currentOpen) {
      e.preventDefault();
      setSuggestion(null);
      toggle.close();
    } else if (key === "Enter" && currentOpen) {
      e.preventDefault();
      select(list.getFocused());
    } else if (key === "ArrowDown") {
      e.preventDefault();
      if (currentOpen) {
        setFocused(list.next());
      } else {
        return toggle.open();
      }
    } else if (key === "ArrowUp") {
      e.preventDefault();
      if (altKey)
        return toggle.close();
      if (currentOpen) {
        setFocused(list.prev());
      }
    }
  };
  function focus(opts) {
    if (inputRef.current)
      inputRef.current.focus(opts);
  }
  function change(nextValue, originalEvent, selected = false) {
    handleChange(nextValue, {
      lastValue: currentValue,
      originalEvent,
      source: selected ? "listbox" : "input"
    });
  }
  (0, import_react.useImperativeHandle)(outerRef, () => ({
    focus
  }));
  let shouldRenderPopup = useFirstFocusedRender(focused, currentOpen);
  let valueItem = accessors.findOrSelf(data, currentValue);
  let inputValue = accessors.text(suggestion || valueItem);
  let completeType = filter ? "list" : "none";
  let popupOpen = currentOpen && (!hideEmptyPopup || !!data.length);
  let inputReadOnly = (
    // @ts-ignore
    (inputProps == null ? void 0 : inputProps.readOnly) != null ? inputProps == null ? void 0 : inputProps.readOnly : readOnly
  );
  let inputAddon = false;
  if (!hideCaret) {
    inputAddon = React.createElement(InputAddon_default, {
      busy,
      icon: selectIcon,
      spinner: busySpinner,
      onClick: handleClick,
      disabled: !!isDisabled || isReadOnly,
      label: messages.openCombobox()
    });
  } else if (busy) {
    inputAddon = React.createElement("span", {
      "aria-hidden": "true",
      className: "rw-btn rw-picker-caret"
    }, busySpinner || Spinner);
  }
  return React.createElement(Widget_default, _extends({}, elementProps, {
    ref,
    open: currentOpen,
    dropUp,
    focused,
    disabled: isDisabled,
    readOnly: isReadOnly
  }, focusEvents, {
    onKeyDown: handleKeyDown,
    className: (0, import_classnames.default)(className, "rw-combobox")
  }), React.createElement(WidgetPicker_default, {
    className: (0, import_classnames.default)(containerClassName, hideCaret && "rw-widget-input", hideCaret && !busy && "rw-hide-caret")
  }, React.createElement(Input_default, _extends({}, inputProps, {
    role: "combobox",
    name,
    id: inputId,
    className: (0, import_classnames.default)(
      // @ts-ignore
      inputProps && inputProps.className,
      "rw-combobox-input",
      !hideCaret && "rw-widget-input"
    ),
    autoFocus,
    tabIndex,
    disabled: isDisabled,
    readOnly: inputReadOnly,
    "aria-busy": !!busy,
    "aria-owns": listId,
    "aria-autocomplete": completeType,
    "aria-expanded": currentOpen,
    "aria-haspopup": true,
    placeholder,
    value: inputValue,
    onChange: handleInputChange,
    onKeyDown: handleInputKeyDown,
    ref: inputRef
  })), inputAddon), React.createElement(FocusListContext.Provider, {
    value: list.context
  }, shouldRenderPopup && React.createElement(Popup, _extends({}, popupProps, {
    dropUp,
    open: popupOpen,
    transition: popupTransition,
    onEntering: () => listRef.current.scrollIntoView()
  }), React.createElement(ListComponent, _extends({}, listProps, {
    id: listId,
    tabIndex: -1,
    data,
    groupBy,
    disabled: disabled2,
    accessors,
    renderItem: renderListItem,
    renderGroup: renderListGroup,
    optionComponent,
    value: selectedItem,
    searchTerm: valueItem && accessors.text(valueItem) || "",
    "aria-hidden": !popupOpen,
    "aria-labelledby": inputId,
    "aria-live": popupOpen ? "polite" : void 0,
    onChange: (d, meta) => handleSelect(d, meta.originalEvent),
    ref: listRef,
    messages: {
      emptyList: rawData.length ? messages.emptyFilter : messages.emptyList
    }
  })))));
});
ComboboxImpl.displayName = "Combobox";
ComboboxImpl.propTypes = propTypes;
var Combobox_default = ComboboxImpl;
export {
  Combobox_default as default
};
//# sourceMappingURL=react-widgets_Combobox.js.map
